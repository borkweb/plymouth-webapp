<?php

/*
 * PSUTools.class.php
 *
 * === Modification History ===
 * 1.00.0  16-may-2006  [mtb]  original
 * 1.01.0  10-Oct-2006  [zbt]  added makeClean
 * 1.02.0  06-dec-2006  [mtb]  added vomit
 * 1.03.0  17-jan-2006  [zbt]  made cleanKeys work for any depth array, recursively
 * 1.04.0  23-feb-2007  [mtb]  added hurl
 * 1.05.0  12-sep-2007  [mtb]  added translateDateArray
 * 1.06.0  11-apr-2008  [amb]  added truncateString
 * 1.06.0  21-apr-2008  [amb]  updated puke to accept variable number of arguments
 * 1.07.0  31-jul-2008  [ncb]  added is_email to do email verification, based on wordpress
 * 1.08.0  12-aug-2008  [ncb]  added seemsUtf8 and removeAccents
 * 1.09.0  02-sep-2008  [ncb]  added parseInput
 * 1.10.0  15-oct-2008  [ncb]  added searchPhonebook
 * 1.11.0  08-jan-2009  [ncb]  added mail
 */

/**
 * @mainpage PSU Documentation
 *
 * @section welcome Welcome
 *
 * Welcome to the docs. All our home grown APIs living in <tt>/web/includes_psu</tt> are documented in this space. This documentation is automatically
 * generated by <a href="http://www.stack.nl/~dimitri/doxygen/">Doxygen</a> using docblock comments within the PHP files. For an example of a well-documented
 * class, check out PSU.
 *
 * For more information, check these links:
 * - <a href="http://www.stack.nl/~dimitri/doxygen/">Doxygen website</a>
 * - <a href="http://www.stack.nl/~dimitri/doxygen/commands.html">documentation commands</a>
 *
 * @section seealso See Also
 * - <a href="http://www.dev.plymouth.edu/webapp/doc/apps/html/">Webapp docs</a>
 *
 * @section banner Banner API Documentation
 * - Advancement: <a href="../banner/advanc/">7.4</a>, <a href="../banner/8/advanc/">8.2</a>
 * - Accounts Receivable: <a href="../banner/ar/">7.3</a>, <a href="../banner/8/arsys/">8.1</a>
 * - Financial Aid: <a href="../banner/finaid/">7.9</a>, <a href="../banner/8/finaid/">8.3.1</a>
 * - General: <a href="../banner/general/">7.5</a>, <a href="../banner/8/general/">8.2</a>
 * - Student: <a href="../banner/student/">7.3.1</a>, <a href="../banner/8/student/">8.2</a>
 *
 * <small>(To edit this file, modify the \@mainpage docblock within PSUTools.class.php.)</small>
 */

/**
 * @brief PSU tools.
 *
 * @version		1.1.0
 * @author		Matthew Batchelder <mtbatchelder@plymouth.edu>
 */ 

class PSU
{
	/**
	 * $WORD_BOUNDARIES
	 */
	public static $WORD_BOUNDARIES = " \n\t<.";

	/**
	 * stores all of the filters
	 */
	public static $filter;

	/**
	 * stores the list of current filters with the current one last
	 */
	public static $current_filter;

	/**
	 * stores the number of times an action was triggered
	 */
	public static $actions;

	/**
	 * stores merged filter hooks
	 */
	public static $merged_filters;

	/**
	 * Built-in database shortcuts for the registry.
	 */
	public $databases = array(
		'audit' => 'mysql/audit/pdo',
		'banner' => 'oracle/psc1_psu/fixcase',
		'rbanner' => 'oracle/psldg_psu/fixcase',
		'ban8' => 'oracle/ban8_psu/fixcase',
		'hub' => 'mysql/hub',
		'hub_dev' => 'mysql/hub_dev',
		'pods' => 'oracle/pods_psu/fixcase',
		'psc1' => 'oracle/psc1_psu/fixcase',
		'psldg' => 'oracle/psldg_psu/fixcase',
		'rept' => 'oracle/rept_psu/fixcase',
		'trng' => 'oracle/trng_psu/fixcase',
		'test' => 'oracle/test_psu/fixcase',
		'dolt' => 'oracle/dolt_psu/fixcase',
		'calllog' => 'mysql/calllog/pdo',
		'conv' => 'oracle/conv_psu/fixcase',
		'conx' => 'oracle/conx_psu/fixcase',
		'connect' => 'mysql/connect/pdo',
		'connect_dev' => 'mysql/connect_dev/pdo',
		'connect_prod' => 'mysql/connect/pdo',
		'cts' => 'mysql/cts/pdo',
		'glpi' => 'mysql/glpi/pdo',
		'glpi_dev' => 'mysql/glpi_dev/pdo',
		'go' => 'mysql/go/pdo',
		'go_dev' => 'mysql/go_dev/pdo',
		'hr' => 'mysql/hr/pdo',
		'idm' => 'oracle/psc1_psu/fixcase',
		'ipool' => 'mysql/ipool/pdo',
		'luminis' => 'oracle/luminis/fixcase',
		'eldoom' => 'mysql/eldoom',
		'emergency_notification' => 'mysql/emergency_notification/pdo',
		'emergency_notification_dev' => 'mysql/emergency_notification_dev/pdo',
		'emergency_notificationt' => 'mysqlt/emergency_notification',
		'emergency_notification_devt' => 'mysqlt/emergency_notification_dev',
		'mahara' => 'mysql/mahara',
		'mahara_dev' => 'mysql/mahara_dev',
		'moodle' => 'mysql/moodle',
		'moodle_dev' => 'mysql/moodle_dev',
		'moodle2' => 'mysql/moodle2',
		'moodle2_dev' => 'mysql/moodle2_dev',
		'moved_moodle' => 'mysql/moved_moodle',
		'live_moodle' => 'mysql/moodle',
		'myplymouth' => 'mysql/myplymouth/pdo',
		'myplymouth_dev' => 'mysql/myplymouth_dev/pdo',
		'phonebook' => 'mysql/phonebook',
		'surplus' => 'mysql/surplus/pdo',
		'surplus_dev' => 'mysql/surplus_dev/pdo',
		'systems' => 'mysql/systems/pdo',
		'portal' => 'mysql/portal/pdo',
		'portal_dev' => 'mysql/portal_dev/pdo',
		'psp' => 'oracle/psc1_psu_psp/fixcase',
		'psu_analytics' => 'oracle/psc1_psu_analytics/fixcase',
		'psuprod' => 'oracle/psuprod_psu/fixcase',
		'r25' => 'oracle/r25_webviewer/fixcase',
		'raintix' => 'mysql/raintix',
		'reslife' => 'mysql/reslife',
		'reslife_dev' => 'mysql/reslife_dev',
		'userinfo' => 'mysql/user_info-admin/pdo',
		'webct_portal' => 'oracle/webct_portal/fixcase',
		'pegasys' => 'mssql/pegasys'
	);
	
	public $dbconn = array();

	/**
	 * Built-in non-database shortcuts for the registry.
	 */
	public $shortcuts = array(
		'ad' => array('PSUadLDAP', '__construct'),
		'facebook' => array('Facebook', '__construct'),
		'gdata' => 'PSU::google_service_init',
		'idmobject' => array('IDMObject', '__construct'),
		'lms' => array('WebCT', '__construct'),
		'log' => array('PSULog', '__construct'),
		'luminisportal' => array('portal', '__construct'),
		'mc' => array('PSUMemcache', '__construct'),
		'zimbraadmin' => 'ZimbraAdmin::factory',
		'phpmailer' => array('PHPMailer', '__construct'),
	);

	// functions that can be mimicked by curl()
	const FILE = 0;
	const FOPEN = 1;
	const READFILE = 2;
	const FILE_GET_CONTENTS = 3;

	// types of includes
	const I_INCLUDE = 0;
	const I_REQUIRE = 1;
	const I_INCLUDE_ONCE = 2;
	const I_REQUIRE_ONCE = 3;

	// is_wpid() flags (bitwise)
	const MATCH_WPID = 1;
	const MATCH_TEMPID = 2;
	const MATCH_BOTH = 3;

	// session_start() flags (bitwise)
	const LOG = 1;
	const NOLOG = 2;
	const FORCE_SSL = 4;
	const ABORT_NOSSL = 8;

	// cdn flags
	const AUTOVERSION = 1;
	const NO_AUTOVERSION = 2;

	// tmp directory
	const TEMPORARY_FILES = '/web/temp/psutools';

	// varnish box ip (algol.plymouth.edu)
	const PROXY = '158.136.1.105';

	// valid characters for a password (similar-looking chars removed)
	const PASSWORD_CHARS = '23456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghjkmnpqrstuvwxyz';

	/** Base upload directory. */
	const UPLOAD_DIR = '/web/uploads';

	/**
	 * Hooks a function on to a specific action.
	 *
	 * Actions are the hooks that the WordPress core launches at specific points
	 * during execution, or when specific events occur. Plugins can specify that
	 * one or more of its PHP functions are executed at these points, using the
	 * Action API.
	 *
	 * @uses add_filter() Adds an action. Parameter list and functionality are the same.
	 *
	 * stolen from wordpress
	 *
	 * @param string $tag The name of the action to which the $function_to_add is hooked.
	 * @param callback $function_to_add The name of the function you wish to be called.
	 * @param int $priority optional. Used to specify the order in which the functions associated with a particular action are executed (default: 10). Lower numbers correspond with earlier execution, and functions with the same priority are executed in the order in which they were added to the action.
	 * @param int $accepted_args optional. The number of arguments the function accept (default 1).
	 */
	public static function add_action($tag, $function_to_add, $priority = 10, $accepted_args = 1) {
		return self::add_filter($tag, $function_to_add, $priority, $accepted_args);
	}

	/**
	 * Add a database shortcut.
	 * @param $shortcut \b string the shortcut name
	 * @param $connection \b string the PSUDatabase connection string
	 */
	public function add_database( $shortcut, $connection )
	{
		$this->databases[$shortcut] = $connection;
	}//end add_database

	/**
	 * Hooks a function or method to a specific filter action.
	 *
	 * Filters are the hooks that WordPress launches to modify text of various types
	 * before adding it to the database or sending it to the browser screen. Plugins
	 * can specify that one or more of its PHP functions is executed to
	 * modify specific types of text at these times, using the Filter API.
	 *
	 * To use the API, the following code should be used to bind a callback to the
	 * filter.
	 *
	 * <code>
	 * function example_hook($example) { echo $example; }
	 * add_filter('example_filter', 'example_hook');
	 * </code>
	 *
	 * In WordPress 1.5.1+, hooked functions can take extra arguments that are set
	 * when the matching do_action() or apply_filters() call is run. The
	 * $accepted_args allow for calling functions only when the number of args
	 * match. Hooked functions can take extra arguments that are set when the
	 * matching do_action() or apply_filters() call is run. For example, the action
	 * comment_id_not_found will pass any functions that hook onto it the ID of the
	 * requested comment.
	 *
	 * <strong>Note:</strong> the function will return true no matter if the
	 * function was hooked fails or not. There are no checks for whether the
	 * function exists beforehand and no checks to whether the <tt>$function_to_add
	 * is even a string. It is up to you to take care and this is done for
	 * optimization purposes, so everything is as quick as possible.
	 *
	 * stolen from wordpress
	 *
	 * @param string $tag The name of the filter to hook the $function_to_add to.
	 * @param callback $function_to_add The name of the function to be called when the filter is applied.
	 * @param int $priority optional. Used to specify the order in which the functions associated with a particular action are executed (default: 10). Lower numbers correspond with earlier execution, and functions with the same priority are executed in the order in which they were added to the action.
	 * @param int $accepted_args optional. The number of arguments the function accept (default 1).
	 * @return boolean true
	 */
	public static function add_filter( $tag, $function, $priority = 10, $accepted_args = 1 ){

		$idx = self::_filter_build_unique_id($tag, $function, $priority);

		self::$filter[ $tag ][ $priority ][ $idx ] = array('function' => $function, 'accepted_args' => $accepted_args);
		unset( self::$merged_filters[ $tag ] );
		return true;
	}//end add_filter
	
	/**
	 * This function makes it easy to accept a fields paramater in a function and have it format the fields passed in correctly 
	 * to work in database queries
	 *
	 * @param string,array $fields the fields to be formated for a sql statement
	 * @param string $table the table to prefix the fields. 
	 * @return string
	 */
	public static function sql_select_fields( $fields, $table = null ) {
		if( $fields ) {
			if( is_array( $fields ) ) {
				if( $table ) {
					return $table.'_'.implode( ', '.$table.'_', $field );
				}
				else {
					return implode( ', ', $field );
				}
			}
			else {
				if( $table ) {
					return $table.'_'.$fields;
				}
				else {
					return $fields;
				}
			}
		}
		else {
			return '*';
		}
	}

	/**
	 * Add an object shortcut to the registry. For database shortcuts, use PSU::add_database().
	 * @param $shortcut \b string the shortcut name
	 * @param $callback \b <a href="http://www.php.net/callback">callback</a> the callback that will create the target object
	 */
	public function add_shortcut( $shortcut, $callback )
	{
		$this->shortcuts[$shortcut] = $callback;
	}//end add_shortcut

	/**
	 * Get an \PSU\API singleton. 
	 * @param $identifier \b string the application identifier (must correspond with a configuration file in /etc/httpd/conf/admin/other/api_*.php)
	 */
	public static function api( $identifier ) {
		static $apis = array();

		if( ! isset( $apis[ $identifier ] ) ) {
			include 'other/api_'. preg_replace( '/[^a-zA-Zi0-9\-_]/', '', $identifier ) .'.php';

			if( ! $_API_CONFIG[ $identifier ] ) {
				throw new \UnexpectedValueException("The {$identifier} API does not have a valid configuration file.");
			}//end if

			$apis[ $identifier ] = new \PSU\API( $_API_CONFIG[ $identifier ] );
		}//end if

		return $apis[ $identifier ];
	}//end api

	/**
	 * Call the functions added to a filter hook.
	 *
	 * The callback functions attached to filter hook $tag are invoked by calling
	 * this function. This function can be used to create a new filter hook by
	 * simply calling this function with the name of the new hook specified using
	 * the $tag parameter.
	 *
	 * The function allows for additional arguments to be added and passed to hooks.
	 * <code>
	 * function example_hook($string, $arg1, $arg2)
	 * {
	 *		//Do stuff
	 *		return $string;
	 * }
	 * $value = apply_filters('example_filter', 'filter me', 'arg1', 'arg2');
	 * </code>
	 *
	 * @param string $tag The name of the filter hook.
	 * @param mixed $value The value on which the filters hooked to <tt>$tag</tt> are applied on.
	 * @param mixed $var,... Additional variables passed to the functions hooked to <tt>$tag</tt>.
	 * @return mixed The filtered value after all hooked functions are applied to it.
	 */
	public static function apply_filters( $tag, $value ){
		$args = array();
		self::$current_filter[] = $tag;

		/* we won't bother with the all hook for now until we need it 
		// Do 'all' actions first
		if ( isset($filter['all']) ) {
			$args = func_get_args();
			_wp_call_all_hook($args);
		}
		 */

		if ( !isset(self::$filter[$tag]) ) {
			array_pop(self::$current_filter);
			return $value;
		}

		// Sort
		if ( !isset( self::$merged_filters[ $tag ] ) ) {
			ksort(self::$filter[$tag]);
			self::$merged_filters[ $tag ] = true;
		}

		reset( self::$filter[ $tag ] );

		if ( empty($args) )
			$args = func_get_args();

		do {
			foreach( (array) current(self::$filter[$tag]) as $the_ )
				if ( !is_null($the_['function']) ){
					$args[1] = $value;
					$value = call_user_func_array($the_['function'], array_slice($args, 1, (int) $the_['accepted_args']));
				}

		} while ( next(self::$filter[$tag]) !== false );

		array_pop( self::$current_filter );

		return $value;
	}//end apply_filters

	/**
	 * Output a backtrace, wrapped by &lt;pre&gt; tags.
	 *
	 * @param string $before Text to output before the backtrace.
	 * @param string $after Text to output after the backtrace.
	 * @param string $return True to return the backtrace as a string, false to echo it.
	 * @param string $escape True to escape the backtrace for display on an HTML page.
	 */
	public static function backtrace($before = '<pre>', $after = '</pre>', $return = false, $escape = false)
	{
		if( ! $return && ! $escape ) {
			echo $before;
			debug_print_backtrace();
			echo $after;

			return;
		}

		ob_start();
		debug_print_backtrace();
		$backtrace = ob_get_clean();

		if( $escape ) {
			$backtrace = str_replace("\n,", '\n,', $backtrace);
			$backtrace = htmlentities($backtrace);
		}

		if( $return ) {
			return $before . $backtrace . $after;
		}

		echo $before . $backtrace . $after;
}//end backtrace

	/**
	 * Modify a URL to point at the CDN.
	 * @todo implement memcache and version numbers
	 * @todo web ui to easily bump version numbers (ie. path LIKE); clears cache
	 */
	public static function cdn( $url = '', $autoversion = self::AUTOVERSION ) {
		// currently disabled unless explictly enabled
		if( defined('PSU_CDN') && PSU_CDN == false ) {
			return $url;
		}

		if( false !== strpos( $GLOBALS['BASE_URL'], '/webapp/banner/' ) ) {
			return $url;
		}

		if( false !== strpos( $url, ".php" ) ) {
			return $url;
		}

		$mc = self::get('mc/cdn');

		$orig_url = $url;

		//
		// first massage the url
		//

		static $searches = array(
			'www.plymouth.edu',
			'www.dev.plymouth.edu'
		);

		static $replaces = array(
			's0.plymouth.edu',
			's0.dev.plymouth.edu'
		);

		// full url with protocol + domain
		if( 'http://' === substr($url, 0, 7) || 'https://' === substr($url, 0, 8) ) {
			$url = str_replace( $searches, $replaces, $url );
		}

		// absolute path
		elseif( '/' === substr($url, 0, 1) ) {
			$host = PSU::isdev() ? 's0.dev.plymouth.edu' : 's0.plymouth.edu';
			$proto = isset($_SERVER['HTTPS']) && $_SERVER['HTTPS'] === 'on' ? 'https://' : 'http://';

			$new = $proto . $host;

			$url = $new . $url;
		}

		// relative path; ignored
		else {
			return $url;
		}

		// nothing else to do for non-cdn urls
		if( preg_match('!https?://s\d+\.(dev\.)?plymouth\.edu/!', $url ) == 0 ) {
			return $url;
		}

		// if requested, stop here without changing version number embedded in url
		if( $autoversion == self::NO_AUTOVERSION ) {
			return $url;
		}

		// trim off query string from this resource
		if( false !== ($pos = strpos($url, "?")) ) {
			$url = substr($url, 0, $pos);
		}

		// Let's serve JavaScript files from a seperate subdomain, so we can utilize multiple parallel HTTP connections
		//
		// Parse the url
		$url_fragments = parse_url($url);

		// Check the path and host for safety
		if( '.js' === substr( $url_fragments['path'], -3 ) && 's0.' === substr( $url_fragments['host'], 0, 3  ) ) {
			// Replace s0. with s1.
			$url = str_replace( '://s0.', '://s1.', $url );
		}

		//
		// then consult memcache to find out if we have a version number
		//
		
		$slash = 0;
		$path = null;
		for( $i = 0, $len = strlen($url); $i < $len; $i++ ) {
			if( '/' === $url[$i] ) {
				$slash += 1;
			}

			if( $slash == 3 ) {
				$path = substr($url, $i);
				break;
			}
		}

		if( !isset($path) ) {
			return $orig_url;
		}

		// try to get version out of memcached
		$version = $mc->get($path);

		// not in memcached; first attempt, so try to get value from db
		if( $version === false ) {
			$version = (int)PSU::db('myplymouth')->GetOne("SELECT version FROM http_resources WHERE path = ?", array($path));

			if( $version ) {
				$mc->add( $path, $version, false, 120 );
				//self::cdn_parent( $path, $parent );
			} else {
				$version = false;
			}
		}

		// wasn't in memcached or db; add to memcached to reduce db hits, but mark as non-versioned
		if( $version === false ) {
			$version = -1;
			$mc->add( $path, $version, false, 120 );
			//self::cdn_parent( $path, $parent );
		}

		if( $version > 0 ) {
			$url .= '?v=' . $version;
		}

		return $url;
	}//end cdn

	/**
	 * Expire a key in the CDN.
	 */
	public static function cdn_expire( $path ) {
		PSU::get('mc/cdn')->delete( $path );

		//if( $parents = PSU::get('mc/cdn')->get('parents:'.$path) ) {
		//	// bool is throwaway, we store parent in key to avoid collisions
		//	foreach( $parents as $parent => $bool ) {
		//		error_log( 'expire parent: '. $parent );
		//		self::cdn_expire( $parent );
		//	}
		//
		//	PSU::get('mc/cdn')->delete('parents:'.$path);
		//}
	}//end cdn_expire

	/**
	 *
	 */
	public static function cdn_parent( $path, $parent = null) {
		$mc = self::get('mc/cdn');

		$parent_id = PSU::db('myplymouth')->GetOne("SELECT id FROM http_resources WHERE path = ?", array($parent));

		$sql = "INSERT INTO ";
	}//end cdn_parent

	/**
	 * cleanKeys Strlowers and str_replaces array values returned from Oracle
	 *
	 * @since		version 1.0.0
	 * @param  		$needle Search terms
	 * @param  		$replace Replace terms
	 * @param  		$haystack Source array
	 * @return		array
	 */
	public static function cleanKeys($needle,$replace,$haystack)
	{
		if(!is_array($haystack)) $haystack = array($haystack);

		$keys=array_keys($haystack);
		foreach($keys as $key)
		{
			$stripped_key=str_replace($needle,$replace,strtolower($key));
			if(is_array($haystack[$key]))
			{
				$haystack[$stripped_key]=self::cleanKeys($needle,$replace,$haystack[$key]);	
			}//end if
			else
			{
				$haystack[$stripped_key]=$haystack[$key];
			}//end else

			if($key!=$stripped_key)
			{
				unset($haystack[$key]);
			}//end if
		}//end foreach
		return $haystack;
	}//end cleanKeys

	/**
	 * cleanOracle prepares strings for insertion into Oracle tables (replaces single quotes with 2 single quotes)
	 *
	 * @since	version 1.0.0
	 * @param $string String to be cleaned
	 * @return string
	 * @deprecated Use ADOdb binding
	 * @callergraph
	 */
	public static function cleanOracle($string)
	{
		self::logOldCode('PSU::cleanOracle');
		return str_replace("'","''",$string);
	}//end cleanOracle

	/**
   * Ummm...close open tags.  Source: http://codesnippets.joyent.com/posts/show/959
	 */
	public static function closeOpenTags($html){
		// the following line was the original regex tweak by the first commenter.  This was swapped out
		// for the active preg_match_all in use a couple lines down.
		//preg_match_all("#<([a-z]+)(?<!br)( [^/]*)?(?!/)>#iU",$html,$result);

		//put all opened tags into an array
		preg_match_all('#<(?!meta|img|br|hr|input\b)\b([a-z]+)(?: .*)?(?<![/|/ ])>#iU', $html, $result);
		$openedtags=$result[1];

		//put all closed tags into an array
		preg_match_all("#</([a-z]+)>#iU",$html,$result);
		$closedtags=$result[1];
		$len_opened = count($openedtags);
		// all tags are closed
		if(count($closedtags) == $len_opened){
			return $html;
		}

		$openedtags = array_reverse($openedtags);
		// close tags
		for($i=0;$i < $len_opened;$i++) {
			if (!in_array($openedtags[$i],$closedtags)){
				$html .= '</'.$openedtags[$i].'>';
			} else {
				unset($closedtags[array_search($openedtags[$i],$closedtags)]);
			}
		}
		return $html;
	}// end closeOpenTags

	/**
	 * Registry function to return boolean of database connection status. True if database connection was opened
	 * successfully, otherwise false.
	 */
	public static function connected( $db )
	{
		return self::db($db)->IsConnected();
	}//end connected

	/**
	 * converts a given string or set of strings into a valid slug string(s)
	 *
	 * @since		version 1.4.0
	 * @param  		$str A mixed variable
	 */
	public static function createSlug($str)
	{
		$find = array(
			'/[ \/\\\+\=]/',
			'/_+/',
			'/[^a-zA-Z0-9\_\-]/'
		);
		
		$replace = array(
			'-',
			'_',
			''
		);
		
		return strtolower(preg_replace($find,$replace,$str));
	}//end createSlug

	/**
	 * converts a result set or an array to a CSV file
	 *
	 * @param $data \b array or result set
	 * @param $filename \b filename for download
	 * @param $echo \b specifies whether to echo the csv or return as a string.  Defaults to true (echo)
	 */
	public static function csv($data, $filename = null, $echo = true, $quote_all = false)
	{
		if($filename)
		{
			header('Content-type: application/octet-stream');
			header('Content-Disposition: attachment; filename="'.$filename.'"');

			self::downloadfix();
		}//end if
		elseif($echo)
		{
			header('Content-type: text/plain');
		}//end if

		$output = '';

		if(is_array($data))
		{
			//build the headers
			$fields = array_keys($data[0]);
			$csvstring = '';
			foreach($fields as $value)
			{
				if($csvstring != '')
				{
					$csvstring .= ',';
				}//end if

				$csvstring .= is_numeric($value) ? $value : '"'.str_replace('"', '\"', $value).'"';
			}//end foreach

			$output .= $csvstring."\n";

			// build the data rows
			foreach($data as $d)
			{
				$csvstring = '';
				foreach($d as $value)
				{
					if($csvstring != '')
					{
						$csvstring .= ',';
					}//end if

					if( $quote_all ) {
						$csvstring .= '"'.str_replace('"', '\"', $value).'"';
					}
					else {
						$csvstring .= is_numeric($value) ? $value : '"'.str_replace('"', '\"', $value).'"';
					}
				}//end foreach
				$output .= $csvstring."\n";
			}//end foreach
		}//end if
		elseif($data instanceOf ADORecordSet)
		{
			require_once('adodb5/toexport.inc.php');
			$output = rs2csv($data);
		}//end else
		else
		{
			$output = $data;
		}//end else

		if($filename || $echo) echo $output;
		else return $output;
	}//end csv

	/**
	 * curl grab the contents of a remote file with curl, to be used when
	 * allow_url_fopen is disabled.
	 *
	 * @return string
	 */
	public static function curl($url, $style=self::FOPEN)
	{
		static $curlHelper = null;
		if($curlHelper == null)
		{
			$curlHelper = new PSUToolsCurlHelper();
		}//end if

		$f = tempnam(self::TEMPORARY_FILES, 'psutools');
		$fp = fopen($f, 'w');

		$curlHelper->add($f);

		$ch = curl_init();
		curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 5);
		curl_setopt($ch, CURLOPT_DNS_CACHE_TIMEOUT, 5);
		curl_setopt($ch, CURLOPT_TIMEOUT, 15);
		curl_setopt($ch, CURLOPT_URL, $url);
		curl_setopt($ch, CURLOPT_FILE, $fp);
		curl_setopt($ch, CURLOPT_FAILONERROR, true);
		curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);

		curl_exec($ch);

		fflush($fp);
		fclose($fp);

		switch($style)
		{
			case self::FILE: $resource = file($f); break;
			case self::FOPEN: $resource = fopen($f, 'r'); break;
			case self::FILE_GET_CONTENTS: $resource = file_get_contents($f); break;
			case self::READFILE: $resource = readfile($f); break;
			default: throw new Exception('unknown type specified: ' . $style);
		}// end switch

		// throw an exception if the transfer failed
		$http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);
		if($http_code != 200)
		{
			throw new PSUToolsException(PSUToolsException::HTTP_FAILED, $http_code);
		}//end if

		return $resource;
	}//end curl

	/**
	 * Retrieve the name of the current filter or action.
	 *
	 * This function was stolen from WordPress
	 *
	 * @return string Hook name of the current filter or action.
	 */
	function current_filter() {
		return end( self::$current_filter );
	}

	public static function date_diff( $time1, $time2, $format = '%1$s years, %2$s months'){
		// If not numeric then convert texts to unix timestamps
		if (!is_int($time1)) {
			$time1 = strtotime($time1);
		}
		if (!is_int($time2)) {
			$time2 = strtotime($time2);
		}

		// If time1 is bigger than time2
		// Then swap time1 and time2
		if ($time1 > $time2) {
			$ttime = $time1;
			$time1 = $time2;
			$time2 = $ttime;
		}

		// Set up intervals and diffs arrays
		$intervals = array('year','month','week','day','hour','minute','second');
		$diffs = array();

		// Loop thru all intervals
		foreach ($intervals as $interval) {
			// Set default diff to 0
			$diffs[$interval] = 0;
			// Create temp time from time1 and interval
			$ttime = strtotime("+1 " . $interval, $time1);
			// Loop until temp time is smaller than time2
			while ($time2 >= $ttime) {
				$time1 = $ttime;
				$diffs[$interval]++;
				// Create new temp time from time1 and interval
				$ttime = strtotime("+1 " . $interval, $time1);
			}
		}
		if ( $format == 'simple' ) {
			// Loop through each interval
			foreach( $intervals as $interval ) {
				// If the difference in this interval is greater than 0
				if ( $diffs[$interval] > 0 ) {
					// Set the time_ago string to have this difference and interval
					$time_ago = $diffs[$interval] . ' ' . $interval;

					// If the diff is greater than 1
					if ( $diffs[$interval] > 1 ) {
						// Add an 's' to the string
						$time_ago .= 's';
					}

					// We don't want any more granularity... so stop this loop
					break;
				}
			}

			// Return the string
			return $time_ago;
		}
		elseif( $format == 'array'){
			return $diffs;
		} else {
			$text = sprintf($format, $diffs['year'], $diffs['month'], $diffs['day'], $diffs['hour'], $diffs['minute'], $diffs['second']);

			foreach( $intervals as $interval){
				if( $diffs[$interval] == 1 ){
					$search[] = $interval.'s';
					$replace[] = $interval;
				}//end if
			}//end foreach

			return str_replace($search, $replace, $text);
		}//end else
	}//end date_diff

	/** 
	 * Function to return a properly formatted date in the HTML5 datetime attribute machine-readable format
	 * SOURCE: http://www.php.net/manual/en/function.date.php#99807
	 */
	public static function html5_datetime( $intDate = null ) { 
		$strFormat = 'Y-m-d\TH:i:s.uP';
		$strDate = $intDate ? date( $strFormat, $intDate ) : date( $strFormat ) ; 

		return $strDate;
	} // End datetime

	/** 
	 * Function to strip out strange unicode characters, such as smart-quotes
	 * SOURCE: http://stackoverflow.com/a/4583465
	 */
	public static function html_all_entities($str){
		$res = ''; 
		$strlen = strlen($str);
		for($i=0; $i<$strlen; $i++){
			$byte = ord($str[$i]);
			if($byte < 128) // 1-byte char
				$res .= $str[$i];
			elseif($byte < 192); // invalid utf8
			elseif($byte < 224) // 2-byte char
				$res .= '&#'.((63&$byte)*64 + (63&ord($str[++$i]))).';';
			elseif($byte < 240) // 3-byte char
				$res .= '&#'.((15&$byte)*4096 + (63&ord($str[++$i]))*64 + (63&ord($str[++$i]))).';';
			elseif($byte < 248) // 4-byte char
				$res .= '&#'.((15&$byte)*262144 + (63&ord($str[++$i]))*4096 + (63&ord($str[++$i]))*64 + (63&ord($str[++$i]))).';';
		}   
		return $res;
	} // End html_all_entities

	/**
	 * Slightly shorter alias to get(), meant for returning a database.
	 * @todo In PHP 5.3, add a __callStatic so we can PSU::BANNER()->Execute()
	 * @param $db the database alias
	 */
	public static function db( $db = null ) {
		return self::get( $db );
	}

	/**
	 * Output a variable with dBug: http://dbug.ospinto.com/
	 */
	public static function dbug()
	{
		$a = func_get_args();
		echo call_user_func_array(array('PSUTools', 'get_dbug'), $a);
	}//end dbug

	/**
	 * Retrieve the number times an action is fired.
	 *
	 * This function was stolen from WordPress
	 *
	 * @param string $tag The name of the action hook.
	 * @return int The number of times action hook <tt>$tag</tt> is fired
	 */
	function did_action($tag) {
		if ( empty(self::$actions) )
			return 0;

		return count(array_keys(self::$actions, $tag));
	}

	/**
	 * Execute functions hooked on a specific action hook.
	 *
	 * This function invokes all functions attached to action hook $tag. It is
	 * possible to create new action hooks by simply calling this function,
	 * specifying the name of the new hook using the <tt>$tag</tt> parameter.
	 *
	 * You can pass extra arguments to the hooks, much like you can with
	 * apply_filters().
	 *
	 * @see apply_filters() This function works similar with the exception that
	 * nothing is returned and only the functions or methods are called.
	 *
	 * This function was stolen from WordPress
	 *
	 * @param string $tag The name of the action to be executed.
	 * @param mixed $arg,... Optional additional arguments which are passed on to the functions hooked to the action.
	 * @return null Will return null if $tag does not exist in $wp_filter array
	 */
	function do_action($tag, $arg = '') {
		if ( is_array(self::$actions) )
			self::$actions[] = $tag;
		else
			self::$actions = array($tag);

		self::$current_filter[] = $tag;

		/** 
		 * we'll leave the all actions off until we need them
		// Do 'all' actions first
		if ( isset(self::$filter['all']) ) {
			$all_args = func_get_args();
			_wp_call_all_hook($all_args);
		}
		 */

		if ( !isset(self::$filter[$tag]) ) {
			array_pop(self::$current_filter);
			return;
		}

		$args = array();
		if ( is_array($arg) && 1 == count($arg) && is_object($arg[0]) ) // array(&$this)
			$args[] =& $arg[0];
		else
			$args[] = $arg;
		for ( $a = 2; $a < func_num_args(); $a++ )
			$args[] = func_get_arg($a);

		// Sort
		if ( !isset( self::$merged_filters[ $tag ] ) ) {
			ksort(self::$filter[$tag]);
			self::$merged_filters[ $tag ] = true;
		}

		reset( self::$filter[ $tag ] );

		do {
			foreach ( (array) current(self::$filter[$tag]) as $the_ )
				if ( !is_null($the_['function']) )
					call_user_func_array($the_['function'], array_slice($args, 0, (int) $the_['accepted_args']));

		} while ( next(self::$filter[$tag]) !== false );

		array_pop(self::$current_filter);
	}//end do_action


	/**
	 * Execute functions hooked on a specific action hook, specifying arguments in an array.
	 *
	 * @see do_action() This function is identical, but the arguments passed to the
	 * functions hooked to <tt>$tag</tt> are supplied using an array.
	 *
	 * this function was stolen from WordPress
	 *
	 * @param string $tag The name of the action to be executed.
	 * @param array $args The arguments supplied to the functions hooked to <tt>$tag</tt>
	 * @return null Will return null if $tag does not exist in $wp_filter array
	 */
	public static function do_action_ref_array($tag, $args) {
		if ( !is_array(self::$actions) )
			self::$actions = array($tag);
		else
			self::$actions[] = $tag;

		self::$current_filter[] = $tag;

		/**
		 * exclude all actions until we need them
		// Do 'all' actions first
		if ( isset(self::$filter['all']) ) {
			$all_args = func_get_args();
			_call_all_hook($all_args);
		}
		 */

		if ( !isset(self::$filter[$tag]) ) {
			array_pop(self::$current_filter);
			return;
		}

		// Sort
		if ( !isset( self::$merged_filters[ $tag ] ) ) {
			ksort(self::$filter[$tag]);
			self::$merged_filters[ $tag ] = true;
		}

		reset( self::$filter[ $tag ] );

		do {
			foreach( (array) current(self::$filter[$tag]) as $the_ )
				if ( !is_null($the_['function']) )
					call_user_func_array($the_['function'], array_slice($args, 0, (int) $the_['accepted_args']));

		} while ( next(self::$filter[$tag]) !== false );

		array_pop(self::$current_filter);
	}

	/**
	 * Quick function that should be run before forcing file downloads
	 * in Internet Explorer. Without these headers (un)set, IE will fail
	 * to download files over HTTPS.
	 *
	 * @todo empty headers should be set via header_remove() in php > 5.3.0
	 */
	public static function downloadfix() {
		header('Pragma: ');
		header('Cache-Control: ');
	}//end downloadfix

	/**
	 * return the current server's facebook credentials
	 */
	public static function fbAPI()
	{
		include 'other/facebook'.(PSU::isDev() ? '_dev' : '').'.php';
		return $_FB['facebook'];
	}//end fbAPI

	/**
	 * @param $fileserver bool true to show the host's file server rather than the host itself (ie. if the files are on an nfs drive)
	 * @param $host string the hostname to check; 
	 */
	public static function hostname( $fileserver = false, $host = null ) {
		if( !isset($host) ) {
			$host = php_uname('n');
		}

		$host = array_shift(explode('.', $host));

		if( $fileserver ) {
			switch($host) {
				case 'choo':
				case 'cetus':
				case 'cursa': $host = 'capricorn';
			}
		}

		return $host;
	}//end hostname

	/**
	 * Returns true if we are working on a development server, determined by server's
	 * hostname. Will generate an error if run on an unknown host.
	 */
	public static function isdev()
	{
		static $isdev = null;

		// don't run function body more than once
		if( null !== $isdev ) {
			return $isdev;
		}

		// prefer HOSTNAME in the environment, which will be set in Apache.
		// use `uname -n' as a backup.
		if( isset( $_ENV['HOSTNAME'] ) ) {
			$hostname = $_ENV['HOSTNAME'];
		} else {
		 	$hostname = php_uname("n");
		}

		switch( $hostname ) {
			case 'connect.plymouth.edu':
			case 'www.plymouth.edu':
			case 'capricorn.plymouth.edu':
			case 'cursa.plymouth.edu':
			case 'cetus.plymouth.edu':
			case 'chow.plymouth.edu':
			case 'chow':
			case 'choo.plymouth.edu':
			case 'choo':
			case 'perseus.plymouth.edu':
			case 'titan.plymouth.edu':
			case 'titan':
			case 'rigel.plymouth.edu': $isdev = false; break;
			case 'www.dev.plymouth.edu':
			case 'connect.dev.plymouth.edu':
			case 'setebos':
			case 'setebos.dev.plymouth.edu':
			case 'pollux.plymouth.edu':
			case 'lupus.plymouth.edu':
			case 'titan-vm':
			case 'titan-vm.plymouth.edu':
			case 'uranus':
			case 'uranus.dev.plymouth.edu':
			case 'uranus.plymouth.edu': $isdev = true; break;
			default: trigger_error( 'HOSTNAME is set to an unknown value: ' . $hostname, E_USER_ERROR );
		}

		return $isdev;
	}//end isdev

	/**
	 * Returns true if the user matches the params
	 */
	public static function is() {
		static $is = array();

		$client_ip = isset($_SERVER['REMOTE_ADDR']) ? $_SERVER['REMOTE_ADDR'] : false;

		$return = false;

		// loop until something is true
		foreach( func_get_args() as $p ) {
			if( isset( $is[$p] ) ) {
				if( $is[$p] ) {
					return $is[$p];
				}
			} elseif( $p == 'matt' ) {
				$return = $_SESSION['username'] == 'mtbatchelder' ||
					( $client_ip &&
						'portabork.plymouth.edu' == gethostbyaddr( $client_ip )
					);
			} elseif( $p == 'adam' ) {
				$return = $_SESSION['username'] == 'ambackstrom' ||
					'158.136.112.105' === $client_ip;
			} elseif( $p == 'porter' ) {
				$return = $_SESSION['username'] == 'nrporter' || '158.136.112.99' === $client_ip;
			} elseif( preg_match('/(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)/', $p) ) {
				// param is an IP address
				$return = $p == $client_ip;
			} elseif(is_numeric( $p )) {
				// param is numeric so we assume it is a pidm
				$return = $p == $_SESSION['pidm'];
			} else {
				// default to user
				$return = $p == $_SESSION['username'];
			}//end else

			// cache these results for next time
			$is[$p] = $return;

			if( $return ) {
				return $return;
			}
		}//end foreach

		return false;
	}//end is

	/**
	 * Get the singleton. Provide an argument to return that property from the singleton instead of the whole singleton.
	 * @param $db \b string the database alias, or a PSUDatabase::connect()-style name (ie. 'mysql/myplymouth'), or null (default) for the registry itself.
	 */
	public static function get( $var = null ) {
		static $instance = null;

		if( $instance === null ) {
			$instance = new self;
		}

		if( $var ) {
			return $instance->$var;
		}

		return $instance;
	}//end get

  /**
   * gets debug information and inserts it into a string
   *
   * @return string $html
   */
	public static function get_dbug()
	{
		$html = '';
		require_once('dBug.php');

		for($i = 0; $i < func_num_args(); $i++)
		{
			$v = func_get_arg($i);
			ob_start();
			new dBug($v);
			$html .= ob_get_contents();
			ob_end_clean();
		}//end for

		return $html;
	}//end get_dbug()

	/**
	 * Get subversion information for a directory. Copied from MediaWiki: http://svn.wikimedia.org/svnroot/mediawiki/trunk/phase3/includes/specials/SpecialVersion.php
	 */
	public static function get_svn_info( $dir = null) {
		if( null === $dir ) {
			if( isset($GLOBALS['BASE_DIR']) ) {
				$dir = $GLOBALS['BASE_DIR'];
			} else {
				throw new PSUToolsException( PSUToolsException::BASE_DIR_MISSING );
			}
		}

		// http://svnbook.red-bean.com/nightly/en/svn.developer.insidewc.html
		$entries = $dir . '/.svn/entries';

		if( !file_exists( $entries ) ) {
			return false;
		}

		$lines = file( $entries );
		if ( !count( $lines ) ) {
			return false;
		}
		
		// check if file is xml (subversion release <= 1.3) or not (subversion release = 1.4)
		if( preg_match( '/^<\?xml/', $lines[0] ) ) {
			// SimpleXml whines about the xmlns...
			// MediaWiki has their own functions, we'll just use @
			//wfSuppressWarnings();
			$xml = @simplexml_load_file( $entries );
			//wfRestoreWarnings();

			if( $xml ) {
				foreach( $xml->entry as $entry ) {
					if( $xml->entry[0]['name'] == '' ) {
						if( $entry['revision'] && $entry['committed-date'] ) {
							return array(
								'revision' => intval( $entry['committed-rev'] ),
								'date' => strtotime( $entry['committed-date'] )
							);
						}

						return false;
					}
				}
			}
			return false;
		}

		// subversion is release 1.4 or above
		if ( count( $lines ) < 11 ) {
			return false;
		}

		$info = array(
			'date' => strtotime( trim( $lines[9] ) ),
			'revision' => intval( trim( $lines[10] ) )
		);

		return $info;
	}//end get_svn_info

	/**
	 * Get subversion revision for a directory. Copied from MediaWiki: http://svn.wikimedia.org/svnroot/mediawiki/trunk/phase3/includes/specials/SpecialVersion.php
	 */
	public static function get_svn_revision( $dir = null) {
		$info = self::get_svn_info( $dir );

		if ( $info === false ) {
			return false;
		} elseif ( isset( $info['revision'] ) ) {
			return $info['revision'];
		} else {
			return false;
		}
	}//end get_svn_revision

	/**
	 * Fetch a var_dump() into a string.
	 *
	 * @param $v
	 * @return string $html
	 */
	public static function get_var_dump($v)
	{
		ob_start();
		var_dump($v);
		$html = ob_get_contents();
		ob_end_clean();

		return $html;
	}// end get_var_dump($v)

	/**
	 * Initialize the Zend Gdata object.
	 */
	public static function google_service_init()
	{
		static $service = null;

		if( $service === null ) {
			require_once 'PSUDatabase.class.php';
			require_once 'Zend/Loader.php';

			$credentials = PSUDatabase::connect('other/gdata', 'return');

			Zend_Loader::loadClass('Zend_Gdata_ClientLogin');
			Zend_Loader::loadClass('Zend_Gdata_Gapps');
			$client = Zend_Gdata_ClientLogin::getHttpClient($credentials['username'], $credentials['password'], Zend_Gdata_Gapps::AUTH_SERVICE_NAME);
			$service = new Zend_Gdata_Gapps($client, $credentials['domain']);
		}

		return $service;
	}

	/**
	 * Check if any action has been registered for a hook.
	 *
	 * stolen from wordpress
	 *
	 * @param string $tag The name of the action hook.
	 * @param callback $function_to_check optional.  If specified, return the priority of that function on this hook or false if not attached.
	 * @return int|boolean Optionally returns the priority on that hook for the specified function.
	 */
	public static function has_action($tag, $function_to_check = false) {
		return self::has_filter($tag, $function_to_check);
	}//end has_action

	/**
	 * Check if any filter has been registered for a hook
	 *
	 * This function was stolen from WordPress
	 *
	 * @param string $tag The name of the filter hook.
	 * @param callback $function_to_check optional.  If specified, return the priority of that function on this hook or false if not attached.
	 * @return int|boolean Optionally returns the priority on that hook for the specified function.
	 */
	public static function has_filter($tag, $function = false){
		$has = !empty(self::$filter[ $tag ]);

		if( $function === false || $has == false ){
			return $has;
		}//end if

		if( !$idx = self::_filter_build_unique_id( $tag, $function, false ) ){
			return false;
		}//end if

		foreach( (array) array_keys(self::$filter[ $tag ]) as $priority ){
			if( isset( self::$filter[ $tag ][ $priority ][ $idx ] ) ){
				return $priority;
			}//end if
		}//end foreach

		return false;
	}//end has_filter

	/**
	 * print_r the contents of a variable into a textarea
	 *
	 * @since		version 1.4.0
	 * @param  		$mixed A mixed variable
	 */
	public static function hurl($mixed)
	{
		echo '<textarea style="width:90%;" rows="15">';
		print_r($mixed);
		echo '</textarea>';
	}//end hurl

	/**
	 * Converts an HTTP URL to HTTPS, if it is not one already.
	 */
	public static function http2https( $url ) {
		if( strtolower(substr($url, 0, 5)) == 'https' ) {
			return $url;
		}

		return 'https' . substr($url, 4);
	}//end http2https

	/**
	 * Ensures the page being accessed is https
	 */
	public static function https()
	{
		if($_SERVER['HTTPS'] !== "on")
		{
			$host = $_SERVER['HTTP_HOST'];

			if( $host === 'plymouth.edu' )
				$host = 'www.plymouth.edu';

			header("Location: https://".$host.$_SERVER['REQUEST_URI']);
			exit;
		}//end if
	}//end isEmail

	/**
	 * verifies that the provided data is an email address
	 * taken from WordPress: 
	 * http://svn.automattic.com/wordpress/tags/2.6/wp-includes/formatting.php
	 *
	 * @since		version 1.7.0
	 * @param  		$user_email the string to check
	 */
	public static function isEmail( $user_email )
	{
		$chars = '/^[a-zA-Z0-9\+\_\-\.]+@[a-zA-Z0-9\_\-\.]+\.[a-zA-Z0-9]{2,}$/';
		return ((preg_match($chars, $user_email)) ? true : false);
	}//end isEmail

	/**
	 * Return true if the specified file is being included by another script.
	 *
	 * Example usage: $is_included = PSU::isIncluded( __FILE__ );
	 *
	 * @param $file the absolute path to a file (intended for the __FILE__ magic constant)
	 * @return boolean
	 */
	public static function isIncluded( $file )
	{
		if( basename($_SERVER['SCRIPT_FILENAME']) === basename($file) )
		{
			// apache is serving the file we were passed, file is not being included
			return false;
		}//end if

		return true;
	}//end isIncluded

	/**
	 * Returns true if argument looks like a wpid, otherwise false.
	 * @param $wpid \b string the wpid
	 * @param $match \b int bitwise and of PSU::MATCH_WPID and PSU::MATCH_TEMPID, with convenience PSU::MATCH_BOTH
	 */
	public static function is_wpid( $wpid, $match = PSU::MATCH_WPID ) {
		if( !is_string( $wpid ) ) {
			return false;
		}

		$initial = '';
		if( $match & PSU::MATCH_WPID ) $initial = 'p';
		if( $match & PSU::MATCH_TEMPID ) $initial .= 't';

		return (bool) preg_match('/^[' . $initial . ']\d[a-z]{7}$/', $wpid);
	}//end is_wpid

	/**
	 * jsonAndExit outputs the given argument as a JSON string and exits.
	 *
	 * @param			$output the variable to jsonify
	 * @param			$http_status a status code to output, defaulting to 200 OK. note that this will replace any status code you have already set.
	 */
	public static function jsonAndExit($output, $http_status=200)
	{
		if($status != 200)
		{
			header('HTTP/1.1 ' . $http_status);
		}//end if

		header('Content-Type: application/json');

		$json = json_encode($output);
		echo $json;

		exit();
	}//end jsonAndExit
	
	/**
	 * logOldCode logs the old, deprecated code passed in into a DB
	 *
	 * @param $code Code snippet being executed
	 * @callergraph
	 */
	public static function logOldCode($code)
	{
		$trace = debug_backtrace(); // full backtrace
		$backtrace = array(); // our stringified backtrace

		$host = self::hostname(true);
		$file = $_SERVER['SCRIPT_NAME'];
		$uri = $_SERVER['REQUEST_URI'];

		$codehash = md5($host . $code . $file);

		foreach($trace as $i => $line)
		{
			$args = array();
			foreach($line['args'] as $arg)
			{
				if( is_scalar($arg) ) {
					$args[] = $arg;
				} elseif( is_object($arg) ) {
					$args[] = get_class($arg);
				} elseif( is_array($arg) ) {
					$args[] = 'Array';
				} elseif( is_resource($arg) ) {
					$args[] = get_resource_type($arg);
				} else {
					$args[] = '[unknown type]';
				}
			}
			$backtrace[] = "\t at $i  {$line['file']} (line {$line['line']}) -> {$line['function']}(" . join(", ",$args) . ")";
		}

		$backtrace = join("\n", $backtrace);

		$args = array($codehash, $host, $code, $file, $backtrace, $backtrace);

		self::db('audit')->Execute("
			INSERT INTO old_code (codehash, host, code, file, trace, create_date, activity_date) VALUES
				(?, ?, ?, ?, ?, now(), now())
			ON DUPLICATE KEY UPDATE hits = hits + 1, activity_date = now(), trace = ?, fixed = 0
		", $args);

		self::db('audit')->Execute("INSERT DELAYED INTO old_code_uris (codehash, uri) VALUES (?, ?)", array($codehash, $uri));
	}//end logOldCode

	/**
	 * mac determines if the browser loading the page is on a mac
	 *
	 * @boolean
	 */
	public static function mac()
	{
		return preg_match('/(Mac_PowerPC)|(Macintosh)/', $_SERVER['HTTP_USER_AGENT']);
	} // end mac

	/**
	 * This is a funny method to generate goofy phrases.
	 *
	 * %q = quantity (i.e. A couple or A troop)
	 * %d = descriptor (i.e. extremely-smart)
	 * %n = noun (i.e. wombat or zebra)
	 * %a = adjective (i.e. happily or slowly)
	 *
	 * Note: you can capitalize the letter to get a ucfirst executed on the variable
	 */
	public static function madlib($phrase = '%q of %d %n are %a doing stuff.') {
		$number = array(
			'a couple',
			'a handful',
			'a mass',
			'a congregation',
			'a gaggle',
			'a swarm',
			'a pride',
			'a group',
			'a herd',
			'a collection',
			'a school',
			'a flock',
			'a pod',
			'a leap',
			'a troop',
			'a platoon',
			'a caravan',
			'a click',
			'an entourage',
			'a committee',
			'a classroom',
			'a colony',
			'a pace',
			'a drove',
			'a litter',
			'a family',
			'a gang',
			'an army',
			'a coalition',
			'a brood',
			'a set',
			'a horde',
			'an alliance',
			'a bevy',
			'a mob',
			'a scourge',
			'a host',
			'a guild'
		);

		$descriptor = array(
			'extremely smart',
			'serious',
			'chattering',
			'resplendent',
			'diminutive',
			'jovial',
			'devious',
			'noisy',
			'ninja',
			'pirate',
			'saucy',
			'robot',
			'data-minded',
			'dangerous',
			'groovy',
			'regal',
			'like-minded',
			'squeamish',
			'militaristic',
			'extravagent',
			'miniscule',
			'overzealous',
			'prancing'
		);

		$noun = array(
			'monkeys',
			'pigs',
			'camels',
			'wildebeests',
			'marmosets',
			'hippopotamuses',
			'faculty',
			'PATs',
			'Operating Staff',
			'employees',
			'giraffes',
			'elephants',
			'wallabies',
			'squirrels',
			'bees',
			'ballerinas',
			'mice',
			'hampsters',
			'panthers',
			'orangutans',
			'cattle',
			'seals',
			'students',
			'moose',
			'elk',
			'tarsiers',
			'turtles',
			'piranhas',
			'ponies',
			'puppies',
			'kittens',
			'baboons',
			'iguanas',
			'pandas',
			'sea gulls',
			'walruses',
			'platypus',
			'mongooses',
			'tight-rope walkers',
			'clowns',
			'mosquitos',
			'database administrators',
			'beetles',
			'wombats',
			'impalas',
			'bison',
			'badgers',
			'yaks'
		);

		$adverb = array(
			'happily',
			'angrily',
			'laboriously',
			'slowly',
			'cheerfully',
			'joyfully',
			'sneakily',
			'vicariously',
			'hesitantly',
			'contentedly',
			'dexterously',
			'furiously',
			'masterfully',
			'carefully',
			'eagerly',
			'quickly',
			'quietly',
			'gracefully',
			'briskly',
			'awkwardly',
			'grimly',
			'loyally',
			'recklessly',
			'savagely',
			'stylishly',
			'unabashedly',
			'faithfully',
			'frantically',
			'hastily',
			'irritably',
			'merrily',
			'nervously',
			'politely',
			'shakily',
			'victoriously',
			'solemnly'
		);

		$number = $number[ rand( 0, count( $number ) - 1 )];
		$descriptor = $descriptor[rand( 0, count( $descriptor ) - 1 )];
		$noun = $noun[rand( 0, count( $noun ) - 1 )];
		$adverb = $adverb[rand( 0, count( $adverb ) - 1 )];

		$phrase = str_replace( array( '%q', '%Q', '%d', '%D', '%n', '%N', '%a', '%A'), array( $number, ucfirst($number), $descriptor, ucfirst($descriptor), $noun, ucfirst($noun), $adverb, ucfirst($adverb) ), $phrase );
		return $phrase;
	}//end madlib

	/**
	 * Send mail, similar to PHP's mail.
	 *
	 * @section multipart Sending HTML mail
	 *
	 * To send a multipart message with text and HTML parts, set <var>$message</var> to <code>array($text, $html)</code>. To
	 * send HTML only, set <code>$message = 'some html'</code>, and include a <var>$header</var> where <code>array('Content-type' => 'text/html')</code>.
	 *
	 * @since 1.11.0
	 *
	 * @param $to Email address to send message
	 * @param $subject Email subject
	 * @param $message Message contents
	 * @param  $headers Optional. Additional headers.
	 * @param  $attachments Optional. Files to attach.
	 * @return True if mail was sent, false otherwise.
	 */
	public static function mail( $to, $subject, $message, $headers = '', $attachments = array() )
	{
		if ( !is_array($attachments) )
			$attachments = explode( "\n", $attachments );
	
		$phpmailer = PSU::get('phpmailer');

		// Headers
		if ( empty( $headers ) ) {
			$headers = array();
		}//end if 
		elseif ( !is_array( $headers ) ) {
			// Explode the headers out, so this function can take both
			// string headers and an array of headers.
			$tempheaders = (array) explode( "\n", $headers );
			$headers = array();
	
			// If it's actually got contents
			if ( !empty( $tempheaders ) ) {
				// Iterate through the raw headers
				foreach ( (array) $tempheaders as $header ) {
					if ( strpos($header, ':') === false )
						continue;
					// Explode them out
					list( $name, $content ) = explode( ':', trim( $header ), 2 );
	
					// Cleanup crew
					$name = trim( $name );
					$content = trim( $content );

					// Add it to our grand headers array
					$headers[trim( $name )] = trim( $content );
				}//end foreach
			}//end if
		}//end function mail

		// Now that $headers is for-sure full, pull out things that belong elsewhere
		$tempheaders = array();
		foreach( $headers as $name => $content )
		{
			if ( 'from' == strtolower($name) ) {
				if ( strpos($content, '<' ) !== false ) {
					// So... making my life hard again?
					$from_name = substr( $content, 0, strpos( $content, '<' ) - 1 );
					$from_name = str_replace( '"', '', $from_name );
					$from_name = trim( $from_name );

					$from_email = substr( $content, strpos( $content, '<' ) + 1 );
					$from_email = str_replace( '>', '', $from_email );
					$from_email = trim( $from_email );
				}//end if
				else {
					$from_name = trim( $content );
				}//end else
			}//end if 
			elseif ( 'content-type' == strtolower($name) ) {
				if ( strpos( $content,';' ) !== false ) {
					list( $type, $charset ) = explode( ';', $content );
					$content_type = trim( $type );
					$charset = trim( str_replace( array( 'charset=', '"' ), '', $charset ) );
				}//end if 
				else {
					$content_type = trim( $content );
				}//end else
			}//end elseif 
			elseif ( 'cc' == strtolower($name) ) {
				$cc = explode(",", $content);
			}//end elseif 
			elseif ( 'bcc' == strtolower($name) ) {
				$bcc = explode(",", $content);
			}//end elseif
			else {
				$tempheaders[$name] = $content;
			}//end else
		}//end foreach

		// Headers are everything that's left after the last foreach
		$headers = $tempheaders;

		// Empty out the values that may be set
		$phpmailer->ClearAddresses();
		$phpmailer->ClearAllRecipients();
		$phpmailer->ClearAttachments();
		$phpmailer->ClearBCCs();
		$phpmailer->ClearCCs();
		$phpmailer->ClearCustomHeaders();
		$phpmailer->ClearReplyTos();
	
		// From email and name
		// If we don't have a name from the input headers
		if ( !isset( $from_name ) )
			$from_name = 'Plymouth State University';
	
		// If we don't have an email from the input headers
		if ( !isset( $from_email ) )
			$from_email = 'do-not-reply@plymouth.edu';
	
		// Set the from name and email
		$phpmailer->From = $from_email;
		$phpmailer->FromName = $from_name;
	
		// Set destination address
		if(!is_array($to)) $to = explode(',', str_replace(';',',',$to));
		foreach ( (array) $to as $recipient ) {
			$phpmailer->AddAddress( trim($recipient) );
		}//end foreach
	
		// Set mail's subject and body
		$phpmailer->Subject = $subject;
		if( !is_array( $message )){
			$phpmailer->Body = $message;
		}//end if
		else{
			$phpmailer->AltBody = $message[0];
			$phpmailer->Body = $message[1];
			$phpmailer->IsHTML( TRUE );
		}//end else

		// Add any CC and BCC recipients
		if ( !empty($cc) ) {
			foreach ( (array) $cc as $recipient ) {
				$phpmailer->AddCc( trim($recipient) );
			}//end foreach
		}//end if
		if ( !empty($bcc) ) {
			foreach ( (array) $bcc as $recipient) {
				$phpmailer->AddBcc( trim($recipient) );
			}//end foreach
		}//end if
	
		// Set to use SMTP via Owl
		$phpmailer->IsSMTP();
		$phpmailer->Host = 'owl.plymouth.edu';
	
	/*
		these vars may be useful if we decide to use authenticated smtp
		$phpmailer->SMTPAuth = true;
		$phpmailer->Username = "username";
		$phpmailer->Password = "password";
	
		and these for encrypted
		$phpmailer->SMTPSecure 	= 'ssl'; //or 'tls' or ''
		$phpmailer->Port 		= 25;
	
	*/
	
		// Set Content-Type and charset
		// If we don't have a content-type from the input headers
		if ( !isset( $content_type ) ) {
			$content_type = 'text/plain';
		}//end if
	
		// Set whether it's plaintext or not, depending on $content_type
		if ( $content_type == 'text/html' ) {
			$phpmailer->IsHTML( true );
		}//end if 
		else {
			$phpmailer->IsHTML( false );
		}//end else
	
		// If we don't have a charset from the input headers
		if ( !isset( $charset ) ) {
			$charset = 'UTF-8';
		}//end if
	
		// Set the content-type and charset
		$phpmailer->CharSet = $charset;

		// Set custom headers
		if ( !empty( $headers ) ) {
			foreach( (array) $headers as $name => $content ) {
				$phpmailer->AddCustomHeader( sprintf( '%1$s: %2$s', $name, $content ) );
			}//end foreach
		}//end if
	
		if ( !empty( $attachments ) ) {
			foreach ( $attachments as $attachment ) {
				if( is_array($attachment) ) {
					call_user_func_array( array($phpmailer, 'AddAttachment'), $attachment );
				} else {
					$phpmailer->AddAttachment($attachment);
				}
			}//end foreach
		}//end if

		// Send!
		$result = @$phpmailer->Send();
	
		return $result;
	}//end mail

	/**
	 * makeSafe was supposed to eliminate SQL injection. It hasn't done anything
	 * for some time, and now just logs its use to the table of deprecated calls.
	 *
	 * @since	     version 1.0.0
	 * @param      $var a mixed variable
	 * @deprecated
	 */
	public static function makeSafe($var)
	{
		self::logOldCode('PSU::makeSafe');
		return $var;
	}//end makeSafe

	/**
	 * makeClean eliminates XSS attacks injection
	 *
	 * @since		version 1.1.0
	 * @param  		$var a mixed variable
	 * @param $gpc
	 */
	public static function makeClean(&$var,$gpc=false) 
	{
		if ( is_array($var) ) 
		{
			foreach ( $var as $key=>$val ) 
			{
				$this->makeClean($var[$key],$gpc);
			}//end foreach
		}//end if 
		else 
		{
			if ($gpc) 
				$var = stripslashes($var);
			$var = preg_replace("~</?\s*(script|embed|object|applet)[^>]*>~si","",$var);
			$var = preg_replace('~(<[^>]*)(onmouseover|onmouseout|onload|onclick|ondblclick|onfocus|onmousedown|onmouseup|onmousemove|onmouseenter|onmouseleave|onblur|onchange|onkeydown|onkeypress|onkeyup|onabort|ondragdrop|onerror|onload|onmove|onreset|onresize|onselect|onsubmit|onunload)=[^>]*>~si','$1>',$var);
		}//end else
	}//end makeClean

	/**
	 * returns whether or not the current browser is a mobile browser
	 * code taken from: http://mobiforge.com/developing/story/lightweight-device-detection-php#comment-5742
	 */
	public static function mobile() {
		$mobile_browser = 0;

		if(preg_match('/(up.browser|up.link|mmp|symbian|smartphone|midp|wap|phone)/i', strtolower($_SERVER['HTTP_USER_AGENT']))) {
			$mobile_browser++;
		}

		if((strpos(strtolower($_SERVER['HTTP_ACCEPT']),'application/vnd.wap.xhtml+xml')>0) or ((isset($_SERVER['HTTP_X_WAP_PROFILE']) or isset($_SERVER['HTTP_PROFILE'])))) {
			$mobile_browser++;
		}    

		$mobile_ua = strtolower(substr($_SERVER['HTTP_USER_AGENT'],0,4));
		$mobile_agents = array(
			'w3c ','acs-','alav','alca','amoi','audi','avan','benq','bird','blac',
			'blaz','brew','cell','cldc','cmd-','dang','doco','eric','hipt','inno',
			'ipaq','java','jigs','kddi','keji','leno','lg-c','lg-d','lg-g','lge-',
			'maui','maxo','midp','mits','mmef','mobi','mot-','moto','mwbp','nec-',
			'newt','noki','oper','palm','pana','pant','phil','play','port','prox',
			'qwap','sage','sams','sany','sch-','sec-','send','seri','sgh-','shar',
			'sie-','siem','smal','smar','sony','sph-','symb','t-mo','teli','tim-',
			'tosh','tsm-','upg1','upsi','vk-v','voda','wap-','wapa','wapi','wapp',
			'wapr','webc','winw','winw','xda','xda-');

		if(in_array($mobile_ua,$mobile_agents)) {
			$mobile_browser++;
		}

		if (strpos(strtolower($_SERVER['ALL_HTTP']),'operamini')>0) {
			$mobile_browser++;
		}

		if (strpos(strtolower($_SERVER['HTTP_USER_AGENT']),' ppc;')>0) {
			$mobile_browser++;
		}

		if (strpos(strtolower($_SERVER['HTTP_USER_AGENT']),'windows ce')>0) {
			$mobile_browser++;
		} else if (strpos(strtolower($_SERVER['HTTP_USER_AGENT']),'windows')>0) {
			$mobile_browser=0;
		}

		if (strpos(strtolower($_SERVER['HTTP_USER_AGENT']),'iemobile')>0) {
			$mobile_browser++;
		}

		return $mobile_browser > 0;
	}//end mobile

	public static function ordinal_suffix( $i ) {
		$tens = $i % 100;
		$ones = $i % 10;

		if( $tens < 4 || $tens > 20 ) {
			if( $ones == 1 ) return('st');
			if( $ones == 2 ) return('nd');
			if( $ones == 3 ) return('rd');
		}

		return 'th';
	}//end ordinal_suffix

	public static function nvl() {
		for( $i = 0, $count = func_num_args(); $i < $count; $i++ ) {
			$a = func_get_arg($i);

			if( $a ) {
				return $a;
			}
		}

		return null;
	}//end nvl

	/**
	 * onCampus determines if the browser is on campus
	 *
	 */
	public static function onCampus()
	{
		return preg_match('/^158\.136/', $_SERVER['REMOTE_ADDR']) || preg_match('/^10\./', $_SERVER['REMOTE_ADDR']);
	} // end onCampus
	
	/**
	 * Echoes out some text in a formatted way
	 *
	 * @since		version 1.4.0
	 * @param  		$text The text to output
	 */
	public static function out($text)
	{
		$before = 'JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7PGJyLz4KJiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOy4uXywsLX4mIzgyMTc7JiM4MjE3OyYjODIxNzsmIzE3NTsmIzE3NTsmIzE3NTsmIzgyMTc7JiM4MjE3O34tLCwmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7PGJyLz4KJiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7Li4sLSYjODIxNjsmIzgyMTc7IDsgOyA7XywsLS0tLCxfIDsgOyYjODIxNzsmIzgyMTc7LSwmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOy4uXywsLC0tLSwsXyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOzxici8+CiYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOy4sJiM4MjE3OyA7IDsgOywtJiM4MjE2OyAsICwgLCAsICwgJiM4MjE2Oy0sIDsgOyYjODIxNzstLCwsLC0tLX5+JiM4MjE3OyYjODIxNzsmIzgyMTc7JiM4MjE3OyYjODIxNzsmIzgyMTc7fi0tLCwsXyYjODIzMDsuLiwsLX4mIzgyMTc7JiM4MjE3OyA7IDsgOyA7X187JiM4MjE3Oy0sJiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDs8YnIvPgomIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsufCA7IDsgOywmIzgyMTc7ICwgLCAsIF8sLC1+JiM4MjE3OyYjODIxNzsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgJiMxNzU7JiM4MjE3OyYjODIxNzt+JiM4MjE3Oy0sLF8gLCwtfiYjODIxNzsmIzgyMTc7ICwgLCAmIzgyMTY7LCA7JiM4MjE3OywgJiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOzxici8+CiYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOy4mIzgyMTc7LCA7IDsgJiM4MjE2Oy0sICwtfiYjODIxNzsmIzgyMTc7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsmIzgyMTc7JiM4MjE3Oy0sICwgLCAsICwgLCYjODIxNzsgOyB8JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOzxici8+CiYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMTc7LCA7IDssJiM4MjE3OyYjODIxNzsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsmIzgyMTc7LSwgLCAsLSYjODIxNjsgOywtJiM4MjE2OyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDs8YnIvPgomIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7LiwmIzgyMTc7LSYjODIxNjsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsmIzgyMTc7JiM4MjE3Oy0mIzgyMTY7IDssLC0mIzgyMTY7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOy4uPGJyLz4KJiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7Li4sJiM4MjE3OyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgO19fIDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgJiM4MjE2Oy0sJiM4MjE3OyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7Li48YnIvPgomIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDssLSYjODIxNjsgOyA7IDsgOyA7IDsgOyA7IDsgOywtJiM4MjE2OyYjODIxNzsmIzE3NTs6IDogJiM4MjE3OyYjODIxNzstLCA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyBfIDsgOyA7IDsgOyYjODIxNzssJiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsuLjxici8+CiYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7Li4sJiM4MjE3OyA7IDsgOyA7IDsgOyA7IDsgOyA7IDt8IDogOiA6IDogOiA6fCA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyAsLSYjODIxNjsmIzgyMTc7JiMxNzU7OiAmIzE3NTsmIzgyMTc7JiM4MjE3Oy0sIDsgOyA7JiM4MjE3OywmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOy48YnIvPgomIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOy4sJiM4MjE3OyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgJiM4MjE2Oy0sXzogOiBfLC0mIzgyMTY7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IHwgOiA6IDogOiA6IDp8IDsgOyA7IHwmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOzxici8+CiYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7LCYjODIxNzsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7ICYjMTc1OyYjMTc1OyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyYjODIxNzstLCxfIDogOiwtJiM4MjE2OyA7IDsgOyA7fCYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7PGJyLz4KJiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOy4uLC0mIzgyMTY7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyAsLC1+JiM4MjE3OyYjODIxNzsgLCAsICwgLCAsLCwtfn4tLCAsICwgLCBfIDsgOyA7JiMxNzU7JiMxNzU7IDsgOyA7IDsgO3wuLi4uLi4uLi4uLi4uLi4uPGJyLz4KJiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOywtJiM4MjE2OyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOywmIzgyMTc7ICwgLCAsICwgLCAsICwoIDogOiA6IDogOikgLCAsICwgLCYjODIxNzsmIzgyMTc7LSwgOyA7IDsgOyA7IDsgOyA7fC4uLi4uLi4uLi4uLi4uLi48YnIvPgomIzgyMzA7JiM4MjMwOyYjODIzMDsuLC0mIzgyMTY7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsmIzgyMTc7LCAsICwgLCAsICwgLCAsICwmIzgyMTc7fi0tLX4mIzgyMTc7JiM4MjE3OyAsICwgLCAsICwgLCYjODIxNzsgOyA7IDsgOyA7IDsgOyA7JiM4MjE3OywmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7Li48YnIvPgomIzgyMzA7JiM4MjMwOy4sLSYjODIxNjsmIzgyMTc7IDsgXywgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgJiM4MjE2OyYjODIxNzt+LSwsLCwtLX5+JiM4MjE3OyYjODIxNzsmIzgyMTc7JiMxNzU7JiM4MjE3OyYjODIxNzsmIzgyMTc7fi0sLF8gLCAsXywtJiM4MjE2OyA7IDsgOyA7IDsgOyA7IDsgOyAmIzgyMTY7LCYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsuPGJyLz4KJiM4MjMwOy4sLSYjODIxNjsmIzgyMTc7LX4mIzgyMTc7JiM4MjE3OywtJiM4MjE2OyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyB8IDsgOyB8IC4gLiAuIC4gLiAuICwmIzgyMTc7OyAsJiM4MjE3OyYjODIxNzsmIzE3NTsgOyA7IDsgOyA7IDsgOyA7IDsgLF8gOyAmIzgyMTY7LSwmIzgyMzA7JiM4MjMwOyYjODIzMDsuLjxici8+CiYjODIzMDsmIzgyMzA7JiM4MjMwOy4sJiM4MjE3OyA7IDssLSwgOyA7LCA7IDsgOywgOyA7IDsgOyA7IDsgOyA7IDsgOyAmIzgyMTY7LCA7IDsmIzgyMTc7LCAuIC4gLiAuIC4gLiAsICwgLCAgLS0tIA==';
		$after = 'PGJyLz4KJiM4MjMwOyYjODIzMDsmIzgyMzA7LCYjODIxNzstfiYjODIxNzsgLC0mIzgyMTY7LX4mIzgyMTc7JiM4MjE3OyAmIzgyMTY7LCAsLSYjODIxNjsgJiM4MjE2OywgLCwtIDsgOyA7IDsgOyA7IDsgOyAmIzgyMTY7LCA7IDsgJiM4MjE2O34tLCwsLSYjODIxNjsmIzgyMTc7IDsgLCYjODIxNzsgOyA7IDsgOyAmIzgyMTY7LCA7LC0mIzgyMTY7JiM4MjE3OyA7ICYjODIxNjssICwtJiM4MjE2Oyw8YnIvPgomIzgyMzA7JiM4MjMwOyYjODIzMDsuLC0mIzgyMTY7JiM4MjE3OyA7IDsgOyA7IDsgJiM4MjE2OyYjODIxNzsgOyA7IDsmIzgyMTc7JiM4MjE3OyA7IDsgOyA7IDsgOyA7IDsgOyA7ICYjODIxNjsmIzgyMTc7LSwsXyA7IDsgOyBfLC0mIzgyMTY7IDsgOyA7IDsgOyA7JiM4MjE3Oy0mIzgyMTY7JiM4MjE3OyA7IDsgOyAmIzgyMTY7JiM4MjE3OyA7IDsmIzgyMTc7LSw8YnIvPgomIzgyMzA7JiM4MjMwOy4uLC0mIzgyMTY7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsmIzE3NTsmIzE3NTsmIzgyMTc7JiM4MjE3OyYjMTc1OyA7IDsgOyA7IDsgOyA7IDsgLCA7IDsgOyA7IDsgOyA7IDsgOyYjODIxNzsmIzgyMTc7LSw8YnIvPgomIzgyMzA7JiM4MjMwOywtJiM4MjE2OyA7IDsgOyA7IDsgOyA7ICwsIDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyB8LCA7IDsgOyA7IDsgOyA7IDsgOyA7ICYjODIxNjstLDxici8+CiYjODIzMDsuLiwmIzgyMTc7IDsgOyA7IDsgOyA7IDsgOywmIzgyMTc7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7fC4uJiM4MjE3Oy0sXyA7IDsgOyAsIDsgOyA7IDsgOyAmIzgyMTY7LDxici8+CiYjODIzMDsuLCYjODIxNzsgOyA7IDsgOyA7IDsgOyA7IHwgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDssJiM4MjE3OyYjODIzMDsmIzgyMzA7LiYjODIxNzsmIzgyMTc7JiM4MjE3OywtfiYjODIxNzsgOyA7IDsgOyA7ICwmIzgyMTc7PGJyLz4KJiM4MjMwOywmIzgyMTc7IDsgOyA7IDsgOyA7IDsgOyA7JiM4MjE3O34tLCwsLCwtLX5+JiM4MjE3OyYjODIxNzsmIzgyMTc7JiM4MjE3OyYjODIxNzsmIzgyMTc7fi0sLCA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOywmIzgyMTc7JiM4MjMwOy4uLC1+JiM4MjE3OyYjODIxNzsgOyA7IDsgOyA7IDsgLC08YnIvPgomIzgyMzA7fCA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyAmIzgyMTY7LCA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDssJiM4MjE3OyYjODIzMDssLSYjODIxNjsgOyA7IDsgOyA7IDsgOyA7LC0mIzgyMTY7PGJyLz4KJiM4MjMwOyYjODIxNzssIDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyAsLSYjODIxNjsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyAsJiM4MjE3OyYjODIzMDsuJiM4MjE3OywgOyA7IDsgOyBfLCwtJiM4MjE2OyYjODIxNzs8YnIvPgomIzgyMzA7LiYjODIxNzssIDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7ICwtJiM4MjE2OyYjODIxNzsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7LCYjODIxNzsmIzgyMzA7JiM4MjMwOy4mIzgyMTc7JiM4MjE3O35+JiM4MjE3OyYjODIxNzsmIzE3NTs8YnIvPgomIzgyMzA7Li4mIzgyMTc7JiM4MjE3Oy0sIDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgO18sLC0mIzgyMTY7JiM4MjE3OyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgLC0mIzgyMTY7PGJyLz4KJiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjE3OyYjODIxNzt+LSwsXyA7IDsgOyA7IF8sLCwtfiYjODIxNzsmIzgyMTc7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOywtJiM4MjE2Ozxici8+CiYjODIzMDsmIzgyMzA7JiM4MjMwOy4ufCA7IDsgOyYjMTc1OyYjMTc1OyYjODIxNzsmIzgyMTc7JiM4MjE3OyYjODIxNzsmIzE3NTsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7LCwtJiM4MjE2Ozxici8+CiYjODIzMDsmIzgyMzA7JiM4MjMwOy4uJiM4MjE3OywgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7LC0mIzgyMTY7PGJyLz4KJiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwO3wgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7fDxici8+CiYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMTc7LCA7IDsgOyA7IDsgOyA7IDsgOyB+LSwsX19fIDsgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgOyYjODIxNzssPGJyLz4KJiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOy4mIzgyMTc7LCA7IDsgOyA7IDsgOyA7IDsgOyA7IDssLSYjODIxNjsmIzgyMzA7LiYjODIxNzsmIzgyMTc7LSwgOyA7IDsgOyA7IDsgOyA7IDsgOyA7IDsgJiM4MjE2Oyw8YnIvPgomIzgyMzA7JiM4MjMwOyYjODIzMDsuLiwmIzgyMTc7ICYjODIxNjstIDsgOyA7IDsgOyA7IDsgOyA7LC0mIzgyMTY7JiM4MjE3OyYjODIzMDsmIzgyMzA7JiM4MjMwOy4mIzgyMTc7LSwgOyA7IDsgOyA7IDsgOyA7IDsgOyA7ICYjODIxNjssPGJyLz4KJiM4MjMwOyYjODIzMDsmIzgyMzA7LiwmIzgyMTc7IDsgOyYjODIxNzsgOyA7IDsgOyA7IDsgLCwtJiM4MjE2OyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7LiYjODIxNzssIDsgOyA7IDsgOyA7IDsgOyA7IDsgOyYjODIxNzssPGJyLz4KJiM4MjMwOyYjODIzMDsmIzgyMzA7LCYjODIxNzsgOyA7IDsgOyA7IDsgOyA7LC0mIzgyMTY7JiM4MjE3OyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMTc7JiM4MjE3Oy0sIDsgOyA7IDsgOyA7IDsgOyA7IHw8YnIvPgomIzgyMzA7JiM4MjMwOy4uLCYjODIxNzsgOyA7IDsgOyA7IDsgOywsLSYjODIxNjsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMTc7JiM4MjE3OywgOyA7IDsgOyA7IDsgOyA7IHw8YnIvPgomIzgyMzA7JiM4MjMwOy4ufCA7IDsgOyA7IDsgOyA7LCYjODIxNzsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7LCYjODIxNzsgOyA7IDsgOyA7IDsgOyA7LCYjODIxNzs8YnIvPgomIzgyMzA7JiM4MjMwOy4ufCA7IDsgOyA7IDsgOyAsJiM4MjE3OyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOy4uLC0mIzgyMTY7IDsgOyA7IDsgOyA7IDsgLCYjODIxNzsmIzgyMTc7PGJyLz4KJiM4MjMwOyYjODIzMDsuLnwgOyA7IDsgOyA7IDssJiM4MjE3OyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOy4sLSYjODIxNjsgOyA7IDsgOyA7IDsgOyAsLSYjODIxNjs8YnIvPgomIzgyMzA7JiM4MjMwOy4uJiM4MjE3OyxfICwgOyAsIDssJiM4MjE3OyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOy4sJiM4MjE3OyA7IDsgOyA7IDsgOyA7ICwtJiM4MjE2Ozxici8+CiYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIxNzssLCYjODIxNzssJiMxNzU7LCYjODIxNzssJiM4MjE3OyYjODIxNzt8JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7LnwgOyA7IDsgOyA7IDsgOyA7ICYjODIxNjstLSwsPGJyLz4KJiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOy4mIzE3NTsmIzgyMzA7JiM4MjE3OyYjODIxNzsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsuLiYjODIxNzstLCA7IDsgOyA7IDsgOyA7IDsgOyA7JiM4MjE3OyYjODIxNzt+LCw8YnIvPgomIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIxNzsmIzgyMTc7LSwsIDsgOyA7IDsgOyA7IDsgOyA7IDsmIzgyMTc7JiM4MjE3O34tLCw8YnIvPgomIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsuLiYjODIxNzsmIzgyMTc7LSwgOyA7IDsgOyA7ICwsXyA7IDsmIzgyMTc7LSwmIzgyMTc7JiM4MjE3Oy0sPGJyLz4KJiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOy4uJiM4MjE3OywgOyA7IDsgOyA7IDsgJiM4MjE2Oy0sX18sLS0uPGJyLz4KJiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMTc7LSwgOyA7IDssLC1+JiM4MjE3OyYjODIxNzsmIzgyMTc7ICwgLHwsIHw8YnIvPgomIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMzA7JiM4MjMwOyYjODIzMDsmIzgyMTc7JiM4MjE3O34tJiM4MjE2OyYjODIxNztfICwgLCAsLCYjODIxNzssXy8tLSYjODIxNjsgPGJyLz4=';
	
		if(is_array($text))
		{
			$text = print_r($text, true);
		}//end if
		else
		{
			$text = ($text) ? $text : 'Whee';
		}//end else
		
		echo '<div style="font-size: 0.8em;">';
		echo base64_decode($before);
		echo '<div style="display:inline-block;background:#fff;border: 1px solid #ccc;padding: 3px;margin: -7px 0;position:relative;" onmouseover="document.getElementById(\'bear_text\').style.display = \'block\';document.getElementById(\'bear_short_text\').style.display = \'none\';"><div id="bear_short_text" style="display:inline-block;overflow:hidden;width:200px;height:1em;padding:0;margin:0;">"';
		echo $text;
		echo '!"</div><div id="bear_text" style="z-index:1000;border: 1px solid #ccc;background: #fff;display:none;width:800px;position:absolute;top:0;left:0;">';
		echo '<pre>'.$text.'</pre>';
		echo '</div></div>';
		echo base64_decode($after);
		echo '</div>';
	}//end out

	/**
	 * merge an input array with defaults, optionally parsing the input string into an array.
	 *
	 * @since		version 1.9.0
	 * @param     $params  Parameter query string/array
	 * @param  		$default Optional default query string/array
	 */
	public static function params($params, $default = array())
	{
		if(!is_array($params)) parse_str((string) $params, $params);

		// no need to do anything with $defaults if it was blank
		if( count($default) == 0 )
			return $params;

		// we got $defaults, parse it and merge it
		if(!is_array($default)) parse_str((string) $default, $default);
		return array_merge($default, $params);
	}//end params

	/**
	 * alias of params
	 *
	 * @since		version 1.9.0
	 * @param  		$default Default query string/array
	 * @param     $params  Parameter query string/array
	 */
	public static function parseInput( $default, $params )
	{
		return self::params($params, $default);
	}//end parseInput

	/**
	 * Generate a random password.
	 */
	public static function password( $length = 8 )
	{
		return self::randomString( $length, self::PASSWORD_CHARS );
	}//end 

	/**
	 * Get the PDO object for a database connection.
	 */
	public static function pdo( $name )
	{
		return self::db($name)->_connectionID;
	}//end pdo

	/**
	 * retrieves a phonebook record
	 *
	 * @since		version 1.9.0
	 */
	public static function phonebookRecord( $field, $data )
	{
		return self::db('phonebook')->GetRow("SELECT * FROM phonebook WHERE {$field} = ".$GLOBALS['PHONEBOOK']->qstr($data));
	}//end phonebookRecord

	/**
	 * puke print_r the contents of an array. you may pass any number of arguments to this function; each will be puked.
	 *
	 * @since		version 1.0.0
	 */
	public static function puke()
	{
		echo '<pre>';
		for($i = 0; $i < func_num_args(); $i++)
		{
			print_r(func_get_arg($i));
			echo "\n";
		}//end for
		echo '</pre>';
	}//end puke

	/**
	 * get_puke do a puke, but return the results
	 *
	 * @return string $html
	 */
	public static function get_puke()
	{
		ob_start();
		self::puke(func_get_args());
		$html = ob_get_contents();
		ob_end_clean();

		return $html;
	}//end get_puke

	/**
	 * Convenience function for code to tell if we're in QA mode, which may cause them to
	 * use mock data, alter page output, etc. Call with a specific area name to get boolean
	 * true/false if that area is being tested, otherwise
	 *
	 * @param $title string Test if a specific area is being tested. Leave 
	 * @param $psu_debug boolean For testing qadebug itself; overrides value of PSU_DEBUG.
	 */
	public static function qa( $area = null, $psu_debug = null ) {
		if( isset($psu_debug) ) {
			if( ! $psu_debug ) {
				return false;
			}
		} elseif( ! defined('PSU_DEBUG') || ! PSU_DEBUG ) {
			return false;
		}

		if( ! isset($_GET['psu-qa']) || ! $_GET['psu-qa'] ) {
			return false;
		}

		$qa = $_GET['psu-qa'];

		if( isset($area) ) {
			return $area == $qa;
		}

		return $qa;
	}//end qa

	/**
	 * Return a random string.
	 *
	 * @since     version 1.0.0
	 * @param     $length length of string
	 * @param     $pattern a list of characters that may be included in the string. leave null (the default) to allow all alphanumeric characters, upper and lower.
	 * @param     $dupes \b bool true to allow characters from $pattern
	 */
	public static function randomString($length, $pattern = null, $dupes = true)
	{
		if( $pattern === null )
		{
			$pattern = "1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
		}

		// pull all the characters from pattern into an array of their integer values
		$sample = unpack("c*", $pattern);

		$key = '';

		if( $length > count($sample) && ! $dupes)
		{
			throw new PSUToolsException( PSUToolsException::RANDSTR_TOO_LONG_DUPES );
		}

		for($i = 0; $i < $length; $i++)
		{
			$index = array_rand($sample);
			$key .= chr($sample[$index]); //convert to characters as we append

			// user requested no dupes; pull this character out of the string
			if( ! $dupes )
			{
				unset($sample[$index]);
			}
		}//end for

		return $key;
	}//end randomString

	/**
	 * Removes a function from a specified action hook.
	 *
	 * This function removes a function attached to a specified action hook. This
	 * method can be used to remove default functions attached to a specific filter
	 * hook and possibly replace them with a substitute.
	 *
	 * stolen from WordPress
	 *
	 * @param string $tag The action hook to which the function to be removed is hooked.
	 * @param callback $function_to_remove The name of the function which should be removed.
	 * @param int $priority optional The priority of the function (default: 10).
	 * @param int $accepted_args optional. The number of arguments the function accpets (default: 1).
	 * @return boolean Whether the function is removed.
	 */
	public static function remove_action($tag, $function_to_remove, $priority = 10, $accepted_args = 1) {
		return self::remove_filter($tag, $function_to_remove, $priority, $accepted_args);
	}

	/**
	 * Remove all of the hooks from an action.
	 *
	 * stolen from Wordpress
	 *
	 * @param string $tag The action to remove hooks from.
	 * @param int $priority The priority number to remove them from.
	 * @return bool True when finished.
	 */
	public static function remove_all_actions($tag, $priority = false) {
		return self::remove_all_filters($tag, $priority);
	}

	/**
	 * Remove all of the hooks from a filter.
	 *
	 * This function was stolen from WordPress
	 *
	 * @param string $tag The filter to remove hooks from.
	 * @param int $priority The priority number to remove.
	 * @return bool True when finished.
	 */
	function remove_all_filters($tag, $priority = false) {
		if( isset(self::$filter[$tag]) ) {
			if( false !== $priority && isset(self::$$filter[$tag][$priority]) )
				unset(self::$filter[$tag][$priority]);
			else
				unset(self::$filter[$tag]);
		}

		if( isset(self::$merged_filters[$tag]) )
			unset(self::$merged_filters[$tag]);

		return true;
	}

	/**
	 * Removes a function from a specified filter hook.
	 *
	 * This function removes a function attached to a specified filter hook. This
	 * method can be used to remove default functions attached to a specific filter
	 * hook and possibly replace them with a substitute.
	 *
	 * To remove a hook, the $function_to_remove and $priority arguments must match
	 * when the hook was added. This goes for both filters and actions. No warning
	 * will be given on removal failure.
	 *
	 * This function was stolen from WordPress
	 *
	 * @param string $tag The filter hook to which the function to be removed is hooked.
	 * @param callback $function_to_remove The name of the function which should be removed.
	 * @param int $priority optional. The priority of the function (default: 10).
	 * @param int $accepted_args optional. The number of arguments the function accpets (default: 1).
	 * @return boolean Whether the function existed before it was removed.
	 */
	public static function remove_filter($tag, $function_to_remove, $priority = 10, $accepted_args = 1) {

		$function_to_remove = self::_filter_build_unique_id($tag, $function_to_remove, $priority);

		$r = isset(self::$filter[$tag][$priority][$function_to_remove]);

		if ( true === $r) {
			unset(self::$filter[$tag][$priority][$function_to_remove]);
			if ( empty(self::$filter[$tag][$priority]) )
				unset(self::$filter[$tag][$priority]);
			unset(self::$merged_filters[$tag]);
		}

		return $r;
	}// end remove_filter

	/**
	 * Build Unique ID for storage and retrieval.
	 *
	 * The old way to serialize the callback caused issues and this function is the
	 * solution. It works by checking for objects and creating an a new property in
	 * the class to keep track of the object and new objects of the same class that
	 * need to be added.
	 *
	 * It also allows for the removal of actions and filters for objects after they
	 * change class properties. It is possible to include the property $filter_id
	 * in your class and set it to "null" or a number to bypass the workaround.
	 * However this will prevent you from adding new classes and any new classes
	 * will overwrite the previous hook by the same class.
	 *
	 * Functions and static method callbacks are just returned as strings and
	 * shouldn't have any speed penalty.
	 *
	 * this was outright lifted from wordpress wp-includes/plugin.php's _wp_filter_build_unique_id
	 *
	 * @param string $tag Used in counting how many hooks were applied
	 * @param callback $function Used for creating unique id
	 * @param int|bool $priority Used in counting how many hooks were applied.  If === false and $function is an object reference, we return the unique id only if it already has one, false otherwise.
	 * @param string $type filter or action
	 * @return string|bool Unique ID for usage as array key or false if $priority === false and $function is an object reference, and it does not already have a uniqe id.
	 */
	public static function _filter_build_unique_id($tag, $function, $priority){
		static $filter_id_count = 0;

		if ( is_string($function) ) {
			return $function;
		} else if (is_object($function[0]) ) {
			// Object Class Calling
			if ( function_exists('spl_object_hash') ) {
				return spl_object_hash($function[0]) . $function[1];
			} else {
				$obj_idx = get_class($function[0]).$function[1];
				if ( !isset($function[0]->filter_id) ) {
					if ( false === $priority )
						return false;
					$obj_idx .= isset(self::$filter[$tag][$priority]) ? count((array)self::$filter[$tag][$priority]) : $filter_id_count;
					$function[0]->filter_id = $filter_id_count;
					++$filter_id_count;
				} else {
					$obj_idx .= $function[0]->filter_id;
				}
		
				return $obj_idx;
			}
		} else if ( is_string($function[0]) ) {
			// Static Calling
			return $function[0].$function[1];
		}
	}//end _build_unique_filter_id

	/**
	 * removeAccents transliterate accented characters to their a-z near equivalent.
	 * taken from WordPress remove_accents():
	 * http://svn.automattic.com/wordpress/tags/2.6/wp-includes/formatting.php
	 *
	 * @since		version 1.8.0
	 * @param  $string
	 */
	public static function removeAccents( $string ) 
	{
		if ( !preg_match('/[\x80-\xff]/', $string) )
			return $string;
		
		if ( self::seemsUtf8( $string )) {
			$chars = array(
			// Decompositions for Latin-1 Supplement
			chr(195).chr(128) => 'A', chr(195).chr(129) => 'A',
			chr(195).chr(130) => 'A', chr(195).chr(131) => 'A',
			chr(195).chr(132) => 'A', chr(195).chr(133) => 'A',
			chr(195).chr(135) => 'C', chr(195).chr(136) => 'E',
			chr(195).chr(137) => 'E', chr(195).chr(138) => 'E',
			chr(195).chr(139) => 'E', chr(195).chr(140) => 'I',
			chr(195).chr(141) => 'I', chr(195).chr(142) => 'I',
			chr(195).chr(143) => 'I', chr(195).chr(145) => 'N',
			chr(195).chr(146) => 'O', chr(195).chr(147) => 'O',
			chr(195).chr(148) => 'O', chr(195).chr(149) => 'O',
			chr(195).chr(150) => 'O', chr(195).chr(153) => 'U',
			chr(195).chr(154) => 'U', chr(195).chr(155) => 'U',
			chr(195).chr(156) => 'U', chr(195).chr(157) => 'Y',
			chr(195).chr(159) => 's', chr(195).chr(160) => 'a',
			chr(195).chr(161) => 'a', chr(195).chr(162) => 'a',
			chr(195).chr(163) => 'a', chr(195).chr(164) => 'a',
			chr(195).chr(165) => 'a', chr(195).chr(167) => 'c',
			chr(195).chr(168) => 'e', chr(195).chr(169) => 'e',
			chr(195).chr(170) => 'e', chr(195).chr(171) => 'e',
			chr(195).chr(172) => 'i', chr(195).chr(173) => 'i',
			chr(195).chr(174) => 'i', chr(195).chr(175) => 'i',
			chr(195).chr(177) => 'n', chr(195).chr(178) => 'o',
			chr(195).chr(179) => 'o', chr(195).chr(180) => 'o',
			chr(195).chr(181) => 'o', chr(195).chr(182) => 'o',
			chr(195).chr(182) => 'o', chr(195).chr(185) => 'u',
			chr(195).chr(186) => 'u', chr(195).chr(187) => 'u',
			chr(195).chr(188) => 'u', chr(195).chr(189) => 'y',
			chr(195).chr(191) => 'y',
			// Decompositions for Latin Extended-A
			chr(196).chr(128) => 'A', chr(196).chr(129) => 'a',
			chr(196).chr(130) => 'A', chr(196).chr(131) => 'a',
			chr(196).chr(132) => 'A', chr(196).chr(133) => 'a',
			chr(196).chr(134) => 'C', chr(196).chr(135) => 'c',
			chr(196).chr(136) => 'C', chr(196).chr(137) => 'c',
			chr(196).chr(138) => 'C', chr(196).chr(139) => 'c',
			chr(196).chr(140) => 'C', chr(196).chr(141) => 'c',
			chr(196).chr(142) => 'D', chr(196).chr(143) => 'd',
			chr(196).chr(144) => 'D', chr(196).chr(145) => 'd',
			chr(196).chr(146) => 'E', chr(196).chr(147) => 'e',
			chr(196).chr(148) => 'E', chr(196).chr(149) => 'e',
			chr(196).chr(150) => 'E', chr(196).chr(151) => 'e',
			chr(196).chr(152) => 'E', chr(196).chr(153) => 'e',
			chr(196).chr(154) => 'E', chr(196).chr(155) => 'e',
			chr(196).chr(156) => 'G', chr(196).chr(157) => 'g',
			chr(196).chr(158) => 'G', chr(196).chr(159) => 'g',
			chr(196).chr(160) => 'G', chr(196).chr(161) => 'g',
			chr(196).chr(162) => 'G', chr(196).chr(163) => 'g',
			chr(196).chr(164) => 'H', chr(196).chr(165) => 'h',
			chr(196).chr(166) => 'H', chr(196).chr(167) => 'h',
			chr(196).chr(168) => 'I', chr(196).chr(169) => 'i',
			chr(196).chr(170) => 'I', chr(196).chr(171) => 'i',
			chr(196).chr(172) => 'I', chr(196).chr(173) => 'i',
			chr(196).chr(174) => 'I', chr(196).chr(175) => 'i',
			chr(196).chr(176) => 'I', chr(196).chr(177) => 'i',
			chr(196).chr(178) => 'IJ',chr(196).chr(179) => 'ij',
			chr(196).chr(180) => 'J', chr(196).chr(181) => 'j',
			chr(196).chr(182) => 'K', chr(196).chr(183) => 'k',
			chr(196).chr(184) => 'k', chr(196).chr(185) => 'L',
			chr(196).chr(186) => 'l', chr(196).chr(187) => 'L',
			chr(196).chr(188) => 'l', chr(196).chr(189) => 'L',
			chr(196).chr(190) => 'l', chr(196).chr(191) => 'L',
			chr(197).chr(128) => 'l', chr(197).chr(129) => 'L',
			chr(197).chr(130) => 'l', chr(197).chr(131) => 'N',
			chr(197).chr(132) => 'n', chr(197).chr(133) => 'N',
			chr(197).chr(134) => 'n', chr(197).chr(135) => 'N',
			chr(197).chr(136) => 'n', chr(197).chr(137) => 'N',
			chr(197).chr(138) => 'n', chr(197).chr(139) => 'N',
			chr(197).chr(140) => 'O', chr(197).chr(141) => 'o',
			chr(197).chr(142) => 'O', chr(197).chr(143) => 'o',
			chr(197).chr(144) => 'O', chr(197).chr(145) => 'o',
			chr(197).chr(146) => 'OE',chr(197).chr(147) => 'oe',
			chr(197).chr(148) => 'R',chr(197).chr(149) => 'r',
			chr(197).chr(150) => 'R',chr(197).chr(151) => 'r',
			chr(197).chr(152) => 'R',chr(197).chr(153) => 'r',
			chr(197).chr(154) => 'S',chr(197).chr(155) => 's',
			chr(197).chr(156) => 'S',chr(197).chr(157) => 's',
			chr(197).chr(158) => 'S',chr(197).chr(159) => 's',
			chr(197).chr(160) => 'S', chr(197).chr(161) => 's',
			chr(197).chr(162) => 'T', chr(197).chr(163) => 't',
			chr(197).chr(164) => 'T', chr(197).chr(165) => 't',
			chr(197).chr(166) => 'T', chr(197).chr(167) => 't',
			chr(197).chr(168) => 'U', chr(197).chr(169) => 'u',
			chr(197).chr(170) => 'U', chr(197).chr(171) => 'u',
			chr(197).chr(172) => 'U', chr(197).chr(173) => 'u',
			chr(197).chr(174) => 'U', chr(197).chr(175) => 'u',
			chr(197).chr(176) => 'U', chr(197).chr(177) => 'u',
			chr(197).chr(178) => 'U', chr(197).chr(179) => 'u',
			chr(197).chr(180) => 'W', chr(197).chr(181) => 'w',
			chr(197).chr(182) => 'Y', chr(197).chr(183) => 'y',
			chr(197).chr(184) => 'Y', chr(197).chr(185) => 'Z',
			chr(197).chr(186) => 'z', chr(197).chr(187) => 'Z',
			chr(197).chr(188) => 'z', chr(197).chr(189) => 'Z',
			chr(197).chr(190) => 'z', chr(197).chr(191) => 's',
			// Euro Sign
			chr(226).chr(130).chr(172) => 'E',
			// GBP (Pound) Sign
			chr(194).chr(163) => '');
		
			$string = strtr($string, $chars);
		}//end if 
		else {
			// Assume ISO-8859-1 if not UTF-8
			$chars['in'] = chr(128).chr(131).chr(138).chr(142).chr(154).chr(158)
				.chr(159).chr(162).chr(165).chr(181).chr(192).chr(193).chr(194)
				.chr(195).chr(196).chr(197).chr(199).chr(200).chr(201).chr(202)
				.chr(203).chr(204).chr(205).chr(206).chr(207).chr(209).chr(210)
				.chr(211).chr(212).chr(213).chr(214).chr(216).chr(217).chr(218)
				.chr(219).chr(220).chr(221).chr(224).chr(225).chr(226).chr(227)
				.chr(228).chr(229).chr(231).chr(232).chr(233).chr(234).chr(235)
				.chr(236).chr(237).chr(238).chr(239).chr(241).chr(242).chr(243)
				.chr(244).chr(245).chr(246).chr(248).chr(249).chr(250).chr(251)
				.chr(252).chr(253).chr(255);
		
			$chars['out'] = "EfSZszYcYuAAAAAACEEEEIIIINOOOOOOUUUUYaaaaaaceeeeiiiinoooooouuuuyy";
		
			$string = strtr($string, $chars['in'], $chars['out']);
			$double_chars['in'] = array(chr(140), chr(156), chr(198), chr(208), chr(222), chr(223), chr(230), chr(240), chr(254));
			$double_chars['out'] = array('OE', 'oe', 'AE', 'DH', 'TH', 'ss', 'ae', 'dh', 'th');
			$string = str_replace($double_chars['in'], $double_chars['out'], $string);
		}//end else
		
		return $string;
	}//end removeAccents
	
	/**
	 * round time to the nearest interval
	 * @param $timestamp \b timestamp to round
	 * @param $interval \b interval to refer to while rounding
	 * @param $interval_type \b time part to round
	 */
	public static function roundTime($timestamp, $interval = 15, $type = 'minute')
	{
		if(!is_numeric($timestamp)) $timestamp = strtotime($timestamp);

		if($type == 'day') $time = 60 * 60 * 24;
		elseif($type == 'hour') $time = 60 * 60;
		elseif($type == 'second') $time = 1;
		else $time = 60;

		$time_chunk = $time * $interval;

		return round($timestamp / $time_chunk) * $time_chunk;
	}//end roundTime

	/**
	 * Include a file located in a specific named directory. Intended usage would be a "safe" hard-coded
	 * $parent in your script, with a $file argument possibly from a $_GET or other unsafe source.
	 *
	 * @param $parent the parent directory
	 * @param $file the file to include
	 * @param $include_type the function to use to include the file. possible values: PSU::I_INCLUDE, PSU::I_INCLUDE_ONCE, PSU::I_REQUIRE, PSU::I_REQUIRE_ONCE
	 */
	public static function safe_include($parent, $file, $include_type = PSU::I_INCLUDE)
	{
		if(substr($parent, -1) !== '/')
		{
			$parent .= '/';
		}//end if

		$supplied_path = $parent . $file;
		$abspath = realpath($supplied_path);

		if($abspath === false)
		{
			throw new PSUToolsException(PSUToolsException::FILE_NOT_FOUND, $supplied_path);
		}//end if

		if(substr($abspath, 0, strlen($parent)) !== $parent)
		{
			throw new PSUToolsException(PSUToolsException::UNSAFE_INCLUDE, $abspath);
		}//end if

		switch($include_type)
		{
			case self::I_INCLUDE: return include($abspath);
			case self::I_REQUIRE: return require($abspath);
			case self::I_INCLUDE_ONCE: return include_once($abspath);
			case self::I_REQUIRE_ONCE: return require_once($abspath);
			default: throw new PSUToolsException(PSUToolsException::UNKNOWN_INCLUDE_TYPE, $include_type);
		}//end if
	}//end safe_include
	
	/**
	 * searchPhonebook returns an array of people matching the search criteria
	 *
	 * @since	    version 1.10.0
	 * @param     $input
	 */
	public static function searchPhonebook( $input )
	{
		if( is_string($input) ) {
			$input = array('search_phrase' => $input);
		}

		$iterations = 0;

		$arg = self::parseInput( array(
			'search_phrase' => FALSE,
			'empstu' => FALSE,
			'everybody' => FALSE,
			'count' => 10,
			'start' => 0
		), $input );

		$emp = !$arg['empstu'] ? '' : ( 1 == $arg['empstu'] ? 'AND phonebook.emp = 1' : 'AND phonebook.emp = 0' );
		$public = $arg['everybody'] ? '' : 'AND phonebook.public = 1';
		$start = abs( (int) $arg['start'] ) > 100 ? 100 : abs( (int) $arg['start'] );
		$count = abs( (int) $arg['count'] ) > 100 ? 100 : abs( (int) $arg['count'] );

		$where_b = array();
		$where_k = '';
		$search_phrase_arr = explode( ' ', str_replace( '*', '%', trim( $arg['search_phrase'] )));
		foreach( $search_phrase_arr as $val )
		{
			$val = trim($val);
			$val = !strpos( trim( $val ), '%' ) ? self::stripPunct( trim( $val )) .'%' : ereg_replace('[^a-z|0-9|%| ]', '', strtolower( self::removeAccents( $val )));

			// empty values cause this query to freeze
			if( empty($val) || $val == '%' ) {
				continue;
			}

			$iterations += 1;

			$phone_where = "REPLACE(REPLACE(REPLACE(REPLACE(phonebook.phone_of,' ',''),'-',''),')',''),'(','') like ".self::db('phonebook')->quote( '%'.$val )." OR REPLACE(REPLACE(REPLACE(REPLACE(phonebook.phone_vm,' ',''),'-',''),')',''),'(','') like ".self::db('phonebook')->quote( '%'.$val );
			$where_b[] = '('.$phone_where.' OR phonebook.psu_id LIKE '.self::db('phonebook')->quote( $val ).' OR phonebook.name_last LIKE '. self::db('phonebook')->quote( $val ) .' OR phonebook.name_first LIKE '. self::db('phonebook')->quote( $val ) .' )';
			
			$where_k .= str_replace( '%', '*', $val .' '. metaphone( $val ) .' ');
		}//end foreach

		// if we had no successful search terms, don't try to query
		if( count($where_b) == 0 ) {
			return array();
		}
		
		$twiddle = 20;
		foreach( self::db('phonebook')->Execute("SELECT phonebook.*, ( CHAR_LENGTH( phonebook.name_last ) + CHAR_LENGTH( phonebook.name_first ) + CHAR_LENGTH( phonebook.username )) AS len, SUM(rank) AS rank
			FROM phonebook AS phonebook
			LEFT JOIN (
				SELECT *, 5 AS rank FROM phonebook 
				WHERE 1 = 1 
				$public
				AND ". implode( ' AND ', $where_b ) ."
				$emp
			) AS a ON a.pidm = phonebook.pidm
			WHERE 1 = 1 
			$public
			AND (". implode( ' OR ', $where_b ) .")
			$emp
			GROUP BY phonebook.pidm
			ORDER BY rank DESC, len ASC, phonebook.name_last ASC, phonebook.name_first ASC
		") as $res)
		{
			$person[ $res['pidm'] ] = $res;
			if( $res['public'] )
				$res['rank'] += 3;
			$rank[ $res['pidm'] ] = ( $res['rank'] + 2 + $twiddle );
			if( $twiddle )
				$twiddle =- 1;
		}//foreach

		foreach( self::db('phonebook')->Execute("SELECT *, MATCH (name_full, name_last, name_first, name_last_metaphone, name_first_metaphone, username, email, dept, title, hint, phone_of, phone_vm) AGAINST ( ". self::db('phonebook')->quote( $where_k ) .") AS rank
			FROM phonebook
			WHERE 1 = 1 
			$public
			AND (
				MATCH (name_full, name_last, name_first, name_last_metaphone, name_first_metaphone, username, email, dept, title, hint, phone_of, phone_vm) AGAINST ( ". self::db('phonebook')->quote( $where_k ) ." IN BOOLEAN MODE)
				$emp
			)
			ORDER BY rank DESC
		") as $res)
		{
			$person[ $res['pidm'] ] = $res;
			if( $res['public'] )
				$res['rank'] += 3;
			$rank[ $res['pidm'] ] += $res['rank'];
		}//end foreach

		if(is_array($rank))
		{
			arsort( $rank );
			foreach( $rank as $key => $val )
				$new_order[] = $person[ $key ];
			return( array_slice( $new_order, (int) $start, (int) $count ));
		}//end if
		else
		{
			return array();
		}//end else
	}//end searchPhonebook

	/**
	 * converts seconds to an array of years, days, minutes, and seconds
	 *
	 * @param $time \b seconds to calculate
	 */
	public static function seconds_to_time($time)
	{
		if(is_numeric($time)){
			$value = array(
				"years" => 0, "days" => 0, "hours" => 0,
				"minutes" => 0, "seconds" => 0,
			);
			if($time >= 31556926){
				$value["years"] = floor($time/31556926);
				$time = ($time%31556926);
			}
			if($time >= 86400){
				$value["days"] = floor($time/86400);
				$time = ($time%86400);
			}
			if($time >= 3600){
				$value["hours"] = floor($time/3600);
				$time = ($time%3600);
			}
			if($time >= 60){
				$value["minutes"] = floor($time/60);
				$time = ($time%60);
			}
			$value["seconds"] = floor($time);
			return (array) $value;
		}else{
			return (bool) FALSE;
		}
	}//end seconds_to_time

	/**
	 * seemsUtf8 return true if the supplied string appears to be UTF-8 encoded
	 * taken from WordPress seems_utf8():
	 * http://svn.automattic.com/wordpress/tags/2.6/wp-includes/formatting.php
	 *
	 * @since		version 1.8.0
	 */
	public static function seemsUtf8( $Str ) 
	{
		$length = strlen($Str);
		for ($i=0; $i < $length; $i++) {
			if (ord($Str[$i]) < 0x80) continue; # 0bbbbbbb
			elseif ((ord($Str[$i]) & 0xE0) == 0xC0) $n=1; # 110bbbbb
			elseif ((ord($Str[$i]) & 0xF0) == 0xE0) $n=2; # 1110bbbb
			elseif ((ord($Str[$i]) & 0xF8) == 0xF0) $n=3; # 11110bbb
			elseif ((ord($Str[$i]) & 0xFC) == 0xF8) $n=4; # 111110bb
			elseif ((ord($Str[$i]) & 0xFE) == 0xFC) $n=5; # 1111110b
			else return false; # Does not match any model
			for ($j=0; $j<$n; $j++) { # n bytes matching 10bbbbbb follow ?
				if ((++$i == $length) || ((ord($Str[$i]) & 0xC0) != 0x80))
				return false;
			}//end if
		}//end foreach
		return true;
	}//end seemsUtf8

	/**
	 * Return true if the specified wpid looks like a temp wpid.
	 * @param $wpid \b string the wpid to check. won't work correctly on a non-wpid (ie. a psu username)
	 */
	public static function seems_temp_wpid( $wpid ) {
		return substr($temp, 0, 1) == 't';
	}//end seems_temp_wpid

	/**
	 * Handle initial session creation. This function acts as a replacement for two common ways to start a session in our environment:
	 *
	 * \li <code>session_start();</code>
	 * \li <code>require 'session_handler.class.php';</code>
	 *
	 * This should happen very early in your application, usually as the first line of code:
	 *
	 * <pre><code>&lt;?php
	 *
	 *require_once 'PSUTools.class.php';
	 *PSU::session_start();</code></pre>
	 *
	 * The <code>$flags</code> parameter supports four bitwise options, some of which are
	 * mutually exclusive:
	 *
	 * \li PSU::LOG -- explicitly enable logging
	 * \li PSU::NOLOG -- explicitly disable logging
	 * \li PSU::FORCE_SSL -- if caller is http, redirect to https before starting session
	 * \li PSU::ABORT_NOSSL -- if caller is http, throw an E_USER_ERROR; use when redirecting may cause unexpected results
	 *
	 * The default behavior is PSU::FORCE_SSL with PSU::NOLOG.
	 *
	 * If logging is not explicitly set by the user, logging will be enabled,
	 * unless PSU::FORCE_SSL was specified. This allows for the logging of aborted
	 * connections and connections that did not redirect to SSL.
	 *
	 * If both the logging options are specified, LOG will override NOLOG.
	 *
	 * Bitwise operators should be joined using the | (vertical bar) operator:
	 *
	 * <pre><code>PSU::session_start( PSU::LOG | PSU::FORCE_SSL );</code></pre>
	 *
	 * @param $flags int
	 */
	public static function session_start( $flags = null ) {
		$config = \PSU\Config\Factory::get_config();

		$flags = self::session_start_flags($flags);

		if( $flags & self::LOG ) {
			$flags_s = null;

			if( $flags & self::ABORT_NOSSL ) {
				$flags_s = 'ABORT_NOSSL';
			} elseif( $flags & self::FORCE_SSL ) {
				$flags_s = 'FORCE_SSL';
			} else {
				// not forcing https; not aborting http. just session_starting.
				$flags_s = 'HTTP';
			}

			self::logOldCode('PSU::session_start(' . $flags_s . ')');
		}

		// die if we're http, if requested
		if( $flags & self::ABORT_NOSSL ) {
			if( !isset($_SERVER['HTTPS']) || $_SERVER['HTTPS'] != 'on' ) {
				trigger_error('Sorry, this application attempted to load over an insecure connection. ITS has been notified of the problem. For more information, please contact the Help Desk for more information at 603-535-2929.', E_USER_ERROR);
			}
		}

		// first, redirect if we're not on ssl
		if( $flags & self::FORCE_SSL ) {
			self::https();
		}

		// when we have converted our apps over to PSU::session_start(), we will change the
		// cookie name to _psusec_prod and set secure to true.
		//session_name('_psusec_' . (self::isdev() ? 'dev' : 'prod'));
		$s = session_get_cookie_params();
		$s['domain'] = $config->get( 'session', 'cookie_domain', $s['domain'] );
		//$s['secure'] = false;
		session_set_cookie_params($s['lifetime'], $s['path'], $s['domain'], $s['secure'], $s['httponly']);

		session_start();
	}//end session_start

	/**
	 * Setup flags for session_start.
	 */
	public static function session_start_flags( $flags = null ) {
		$config = \PSU\Config\Factory::get_config();

		// handle old-style boolean flags
		if( is_bool($flags) ) {
			// old: $secure = true
			// new: force ssl, don't log
			if( $flags ) {
				$flags = self::NOLOG | self::FORCE_SSL;
			}

			// old: $secure = false
			// new: just log, don't force ssl
			else {
				$flags = self::LOG;
			}
		}

		// default behavior
		if( $flags === null ) {
			$flags = self::NOLOG;

			if( $config->get( 'session', 'force_ssl', true ) ) {
				$flags |= self::FORCE_SSL;
			}
		}

		// if no special logging settings were defined, use our defaults
		if( ! ($flags & ( self::LOG | self::NOLOG)) ) {
			// if request isn't forced to ssl, we want to log it
			if( $flags ^ self::FORCE_SSL ) {
				$flags |= self::LOG;
			}
		}

		return $flags;
	}//end session_start_flags

	/**
	 * stripPunct remove punctuation from a string
	 *
	 * @since		version 1.8.0
	 */
	public static function stripPunct( $string ) 
	{
		return( ereg_replace('[^a-z|0-9| ]', '', strtolower( self::removeAccents( $string ))));
	}//end stripPunct

	/**
	 * translates a year, month, day array to a Y-m-d format
	 *
	 * @since		version 1.5.0
	 * @param  		$array An array of indexes year, month, day
	 * @param  		$default_offset the default offset if an index does not exist
	 * @return  	string
	 */
	public static function translateDateArray($array,$default_offset='today')
	{
		$month = ($array['month'])?$array['month']:date('m',strtotime($default_offset));
		$day = ($array['day'])?$array['day']:date('d',strtotime($default_offset));
		$year = ($array['year'])?$array['year']:date('Y',strtotime($default_offset));
		
		return $year.'-'.$month.'-'.$day;
	}//end translateDateArray

	/**
	 * translates a string in the format Y-m-d to a unix timestamp
	 *
	 * @param      $date the date to translate
	 * @return     mixed a unix timestamp (int) on success, or null on failure
	 */
	public static function translateDateString($date)
	{
		$darr = strptime($date, '%Y-%m-%d');

		if(is_array($darr))
		{
			$darr['tm_year'] += 1900;
			return mktime($darr['tm_hour'], $darr['tm_min'], $darr['tm_sec'], $darr['tm_mon'], $darr['tm_mday'], $darr['tm_year']);
		}//end if

		return null;
	}//end translateDateString

	/**
	 * Returns a specified number of chracters, breaking around words and rounding up.
	 *
	 * @since		version 1.6.0
	 * @param		$str the source string
	 * @param		$max the number of words to return
	 * @param		$ignore_tags whether or not to ignore html tags. defaults to true
	 * @param		$append the string to append to the truncated text.
	 * @return		string
	 */
	public static function truncateString($str, $max = 20, $ignore_tags = true, $append = ' &hellip;')
	{
		$str = trim($str);

		if(empty($str))
		{
			return $str;
		}//end if

		$max = (int)$max;

		if($max >= strlen($str))
		{
			return $str;
		}//end if
		
		// quick and dirty, when no html is involved
		if($ignore_tags)
		{
			// the necessary number of characters, up to the next space or end of line
			$pattern = sprintf('/^(.{%d}.*?)(\s|$)/sm', $max);
			preg_match($pattern, $str, $matches);
			$match = $matches[1];

			// we matched the whole string, just pass it back to the user
			if($match == $str)
			{
				return $str;
			}//end if

			return $matches[1] . $append;
		}//end if

		$printable = 0;  // number of printable characters so far
		$current = 0; // number of real characters so far (includes html)
		$matching = true;
		$tag_stack = array();
		$tag_contents = '';

		for($current = 0; $current < strlen($str); $current++)
		{
			$chr = $str{$current};
			if($chr == '<')
			{
				$matching = false;
			}//end if

			// depending on matching status, either update our character count
			// or resume tracking the html tag
			if($matching)
			{
				$printable++;
			}//end if
			else
			{
				$tag_contents .= $chr;
			}//end else
			
			if($printable > $max && strpos(self::$WORD_BOUNDARIES, $chr) !== false)
			{
				// currently this will miss any additional tags with no content: img, br, etc.
				break;
			}//end if

			if($chr == '>')
			{
				$matching = true;

				if(preg_match('!/\s*>!', $tag_contents) > 0)
				{
					// this is a self-closed tag, nothing needs to be done to the tag stack
				}//end if
				elseif(preg_match('!^<\s*(/?)\s*([^>\s]+)!', $tag_contents, $matches) > 0)
				{
					$close_tag = ($matches[1] == '/') ? true : false;
					$tag_name = strtolower($matches[2]);

					if($close_tag)
					{
						$last = array_pop($tag_stack);
						if($last != $tag_name)
						{
							// this is an error condition which indicates improperly nested tags
							// FIXME: add error handling?
							array_push($tag_stack, $tag_name);
						}//end if
					}//end if
					else
					{
						array_push($tag_stack, $tag_name);
					}//end else
				}//end elseif

				$tag_contents = '';
			}//end if
		}//end for

		// clean up the string and fix the still-open tags, then bail out
		$str = substr($str, 0, $current) . $append;
		while(1)
		{
			$tag = array_pop($tag_stack);

			if($tag == null)
			{
				break;
			}//end if

			$str .= '</' . $tag . '>';
		}//end while
		return $str;
	}//end truncateString

	/**
	 * Return a random MD5 sum.
	 * @return string
	 */
	public static function uid()
	{
		return md5(uniqid(rand(), true));
	}//end uid

	/**
	 * Convert an array of UTF-8 strings to ASCII text. Edits the source array in place.
	 *
	 * @param    $arr the array of strings to update
	 */
	public static function utf8_to_ascii(&$arr)
	{
		foreach($arr as &$item)
		{
			// only operate on strings
			if(!is_string($item))
			{
				continue;
			}//end if

			// $item = iconv("UTF-8", "ASCII//TRANSLIT", $item); // METHOD 1: translate UTF-8 to ASCII equiv., ie. smart quotes to normal quotes
			$item = htmlentities($item, ENT_QUOTES, 'UTF-8'); // METHOD 2: translate UTF-8 to html entity equivalents, ie. smart quote to &rsquo;
		}//end foreach
	}//end utf8_to_ascii

	/**
	 * Fix smart quotes and other bogus characters in ISO-8859-1, replacing with HTML entities.
	 *
	 * @param $html
	 */
	public static function fix_quotes($html)
	{
		$search = array(chr(145), chr(146), chr(147), chr(148), chr(151));
		$replace = array("&lsquo;", "&rsquo;", "&ldquo;", "&rdquo;", "&mdash;");

		return str_replace($search, $replace, $html);
	}//end fix_quotes

	/**
	 * vomit print_r the contents of an array in a contained area
	 *
	 * @since		version 1.2.0
	 * @param  		$array An array
	 * @param     $title
	 * @param  		$width width of area
	 * @param  		$height height of area
	 */
	public static function vomit($array,$title='',$width=1000,$height=300)
	{
		$random_id='vomit_'.rand(0,100000);
		echo '<style>
			.vomit_list{background:#ddd;margin:0px;}
			.vomit_list li{background:#fff;border:1px solid #ccc;padding:3px;}
			.vomit_list li:hover{background:#eee;}
		</style>';
		echo '<ul class="vomit_list"><li><a href="javascript:void(0);" style="font-size:0.9em;" onclick="var el=document.getElementById(\'vomit_'.$random_id.'\'); if(el.style.display==\'none\') el.style.display=\'block\'; else el.style.display=\'none\';"><strong>Debug</strong>'.(($title)?': '.$title:'').'</a>';
		echo '<div id="vomit_'.$random_id.'" class="vomit" style="background:#fff;border:1px solid #666;display:none;height:'.$height.'px;width:'.$width.'px;overflow:auto;margin:5px;padding:3px;"><strong>Output of Debug</strong>'.(($title)?': '.$title:'').'<br/><pre style="font-size:0.9em;">';
		print_r($array);
		echo '</pre></div></li></ul>';
	}//end vomit
	
	/**
	 * parses DOM XML into an associative array
	 * @since       version 1.8.0
	 */
	public static function xml2Array($node, $attributes = false)
	{
		$return = array();
		
		//loop over child nodes
		foreach($node->childNodes as $node_child)
		{
			//does this child node have children?
			if( $node_child->hasChildNodes() )
			{
				//yes! child node has children
				
				//is this a collection of likely named nodes?
				if( $node->firstChild->nodeName == $node->lastChild->nodeName && $node->childNodes->length > 1)
				{
					//yes. add parsed xml as an element of the child node array
						$return[ $node_child->nodeName ][] = self::xml2array( $node_child );
				}//end if
				else
				{
					//no, the child nodes are named differently
					$return[ $node_child->nodeName ] = self::xml2array( $node_child );
				}//end else
			}//end if
			else
			{
				//no children.  This is a leaf
				$return = $node_child->nodeValue;
			}//end else
		}//end foreach
		
		return $return;
	}//end xml2Array

	/**
	 * Prettifies an XML string into a human-readable and indented work of art
	 * http://gdatatips.blogspot.com/2008/11/xml-php-pretty-printer.html
	 *
	 * @param $xml The XML as a string
	 * @param $html_output True if the output should be escaped (for use in HTML)
	 */
	public static function xmlpp($xml, $html_output=false)
	{
		$xml_obj = new SimpleXMLElement($xml);
		$level = 4;
		$indent = 0; // current indentation level
		$pretty = array();

		// get an array containing each XML element
		$xml = explode("\n", preg_replace('/>\s*</', ">\n<", $xml_obj->asXML()));

		// shift off opening XML tag if present
		if (count($xml) && preg_match('/^<\?\s*xml/', $xml[0])) {
			$pretty[] = array_shift($xml);
		}

		foreach ($xml as $el) {
			if (preg_match('/^<([\w])+[^>\/]*>$/U', $el)) {
				// opening tag, increase indent
				$pretty[] = str_repeat(' ', $indent) . $el;
				$indent += $level;
			} else {
				if (preg_match('/^<\/.+>$/', $el)) {            
					$indent -= $level;  // closing tag, decrease indent
				}
				if ($indent < 0) {
					$indent += $level;
				}
				$pretty[] = str_repeat(' ', $indent) . $el;
			}
		}   
		$xml = implode("\n", $pretty);   
		return ($html_output) ? '<pre style="border: 1px solid black; background-color: white; padding: 1ex; margin-bottom: 1em;">' . htmlentities($xml) . '</pre>' : $xml;
	}//end xmlpp

	/**
	 * Singleton constructor (private). Retrieve singleton via <code>PSU::get()</code>.
	 */
	private function __construct()
	{
		require_once('PSUDatabase.class.php');
		if( self::isdev() ) 
		{
			// dev servers should use dev databases in some cases
			$this->add_database('banner', 'oracle/test_psu/fixcase');
			$this->add_database('rbanner', 'oracle/test_psu/fixcase');
			$this->add_database('audit', 'mysql/audit_dev/pdo');
			$this->add_database('connect', 'mysql/connect_dev/pdo');
			$this->add_database('emergency_notification', 'mysql/emergency_notification_dev/pdo');
			$this->add_database('emergency_notificationt', 'mysqlt/emergency_notification_dev');
			$this->add_database('go', 'mysql/go_dev/pdo');
			$this->add_database('glpi', 'mysql/glpi_dev/pdo');
			$this->add_database('hr', 'mysql/hr_dev/pdo');
			$this->add_database('hub', 'mysql/hub_dev/pdo');
			$this->add_database('psp', 'oracle/test_psu_psp/fixcase');
			$this->add_database('phonebook', 'mysql/phonebook_dev/pdo');
			$this->add_database('portal', 'mysql/portal_dev/pdo');
			$this->add_database('calllog', 'mysql/calllog_dev/pdo');
			$this->add_database('cts', 'mysql/cts_dev/pdo');
			$this->add_database('mahara', 'mysql/mahara_dev');
			$this->add_database('moodle', 'mysql/moodle_dev');
			$this->add_database('moodle2', 'mysql/moodle2_dev');
			$this->add_database('myplymouth', 'mysql/myplymouth_dev');
			$this->add_database('reslife', 'mysql/reslife_dev/pdo');
		}//end elseif

		if(isset($_SESSION['psutools_redirect_sid']))
		{
			$this->add_database('banner', 'oracle/'.strtolower($_SESSION['psutools_redirect_sid']).'_psu/fixcase');
		}//end if
	}//end __construct

	/**
	 * @section registry Registry
	 *
	 * In addition to hosting a number of utility functions, %PSU also acts as a registry via singleton. This means
	 * you can use the function <code>PSU::get()</code> from any script and always get the same instantiated %PSU
	 * object. Data can be stored in this registry without resorting to global variables (aka $GLOBALS). This is our
	 * preferred way of storing global objects, because it reduces pollution of the global namespace.
	 *
	 * This preference extends to database objects that were once stored in $GLOBALS: an effort should be made to refer
	 * to database connections stored in the registry.
	 *
	 * @subsection using-the-registry Using the Registry
	 *
	 * Shortcuts are available to quickly access reusable database objects:
	 *
	 * <pre><code>echo PSU::db('myplymouth')->GetOne("SELECT 1 FROM sometable WHERE username = 'ambackstrom'");</code></pre>
	 *
	 * Each time you access <code>PSU::db('myplymouth')</code>, you are given the same database connection. You do not have to
	 * instantiate this connection manually, PSU will do it for you. Requested connection names will be lowercased and checked against
	 * a list of table aliases. The following are equivalent:
	 *
	 * @li PSU::get()->myplymouth -- database as a property of the registry
	 * @li PSU::db('myplymouth') -- preferred shortcut to database alias (lowercase)
	 * @li PSU::db('MyPlymouth') -- alias, with caps
	 * @li PSU::db('MYPLYMOUTH') -- different caps
	 * @li PSU::db('mysql/myplymouth/pdo') -- PSUDatabase connection string
	 *
	 * PHP's chaining provides for some flexibility in dealing with the registry and objects within it. You may do any of the following:
	 *
	 * <pre><code> // create local variables for everything
	 * $r = PSU::get(); // get the registry
	 * $db = $r->myplymouth; // objects are accessible as properties
	 * $db->Execute("UPDATE table WHERE 1=1");
	 *
	 * // do a little chaining
	 * $r = PSU::get();
	 * $r->db('myplymouth')->Execute("UPDATE table WHERE 1=1");
	 *
	 * // chain exclusively
	 * PSU::db('myplymouth')->Execute("UPDATE table WHERE 1=1");</code></pre>
	 *
	 * Because PHP5 creates object references by default, the difference in overhead between these three approaches is minimal. Pick the one
	 * that works for you. (Note: the latter is the closest in style to the old $GLOBALS['MYPLYMOUTH'], and is one character shorter to type.)
	 *
	 * You may also store arbitrary data in the registry:
	 *
	 * <pre><code>PSU::get()->person = new PSUPerson('012345678');</code></pre>
	 *
	 * @subsection object-aliases Object Aliases
	 *
	 * <!-- vim thing: '<,'>s/'\(.*\)' => '\(.*\)',\?/* \li \1 -- \2/ --> A number of object aliases are built-in. Most are database
	 * aliases, with their destination denoted as the PSUDatabase::connect() connection string.
	 *
	 * \li audit -- mysql/audit/pdo
	 * \li banner -- test on uranus, psc1 everywhere else
	 * \li conv -- oracle/conv_psu/fixcase
	 * \li conx -- oracle/conx_psu/fixcase
	 * \li idm -- psc1
	 * \li idmobject -- new IDMObject ('idm' database by default)
	 * \li go -- mysql/go/pdo
	 * \li log -- new PSULog (see PSULog for arguments)
	 * \li luminis -- oracle/luminis/fixcase
	 * \li mc -- new PSUMemcache
	 * \li myplymouth -- mysql/myplymouth/pdo
	 * \li phonebook -- mysql/phonebook
	 * \li pods -- oracle/pods_psu/fixcase
	 * \li portal -- myplymouth/portal/pdo
	 * \li psc1 -- oracle/psc1_psu/fixcase
	 * \li test -- oracle/test_psu/fixcase
	 * \li trng -- oracle/trng_psu/fixcase
	 * \li userinfo -- mysql/user_info-admin/pdo
	 * \li webct_portal -- oracle/webct_portal/fixcase
	 *
	 * Object shortcuts may take arguments, separated by 
	 *
	 * <pre><code>PSU::get('log/12/ambackstrom')->write('some message');</code></pre>
	 *
	 * You may also apply your own database and object shortcuts, for example:
	 *
	 * @include psutools-shortcuts1.php
	 *
	 * @class PSU
	 */

	/**
	 * Magic method to access our common database instances and other "globals." Object
	 * aliases get stored in $this->dbconn under their connection strings.
	 */
	public function __get( $dbname )
	{
		$dbname = strtolower($dbname_get = $dbname);

		// attempt to translate aliases to their connection strings
		$connection_string = isset($this->databases[$dbname]) ? $this->databases[$dbname] : $dbname;

		// do we have a connection using that connection string? we did some transformations
		// to $dbname, which may be forcing us through a new __get.
		//
		//    PSU::get('PSC1'); // sets $this->PSC1 and $this->psc1
		//    PSU::get('oracle/psc1_psu/fixcase'); // sets $this->oracle/psc1_psu/fixcase
		//
		if( !empty($connection_string) && isset($this->dbconn[ $connection_string ]) ) {
			// add the alias to reduce overhead on the next run
			return $this->$dbname_get = $this->$dbname = $this->dbconn[ $connection_string ];
		}

		// check for non-db hooks. may take parameters, separated by slashes. use $dbname_get
		// because parameters may be case-sensitive.
		$tokens = explode('/', $dbname_get);
		$shortcut = array_shift($tokens);
		if( isset($this->shortcuts[$shortcut]) ) {
			// load required libraries, rather than making user include libraries before
			// asking the registry for the classes.
			switch($shortcut) {
				case 'ad': require_once('PSUadLDAP.class.php'); break;
				case 'facebook': 
					require_once 'facebook-platform/facebook.php'; 
					if(empty($tokens))
					{
						$tokens = self::fbAPI();
					}//end if
				break;
				case 'lms': require_once('webct.class.php'); break;
				case 'idmobject': require_once('IDMObject.class.php'); break;
				case 'log': require_once('PSULog.class.php'); break;
				case 'luminisportal': require_once('portal.class.php'); break;
				case 'mc': require_once('PSUMemcache.class.php'); break;
				case 'zimbraadmin': require_once('zimbraAdmin.class.php'); break;
				case 'phpmailer':
					require_once 'phpmailer/class-phpmailer.php';
					require_once 'phpmailer/class-smtp.php';
					break;
			}

			$callback = $this->shortcuts[$shortcut];

			// are we instantiating via the constructor?
			if( is_array($callback) && is_string($callback[0]) ) {
				if( $callback[1] == '__construct' || $callback[1] == $callback[0] ) {
					// yes, constructor is being used. instantiate via reflection.
					$r = new ReflectionClass( $callback[0] );

					if( count($tokens) > 0 ) {
						return $this->$dbname_get = $r->newInstanceArgs($tokens);
					} else {
						return $this->$dbname_get = $r->newInstance();
					}
				}
			}

			if( count($tokens) > 0 ) {
				return $this->$dbname_get = call_user_func_array( $callback, $tokens );
			} else {
				return $this->$dbname_get = call_user_func( $callback );
			}
		}

		// if this is a known alias, instantiate the database
		if( isset($this->databases[ $dbname ]) ) {
			return $this->$dbname_get = $this->$dbname = $this->dbconn[ $connection_string ] = PSUDatabase::connect( $connection_string );
		}

		// not a known alias, is it a database connection string for psudatabase?
		if( false !== strpos($dbname_get, '/') ) {
			return $this->$dbname_get = $this->$dbname = $this->dbconn[ $dbname_get ] = PSUDatabase::connect( $dbname_get );
		}

		// not a known alias, not a database connection string
		throw new Exception('unknown database alias provided: ' . $dbname_get);
	}//end __get

	/**
	 * prepares pagination information used in searches
	 */
	static function paginationInfo(&$params, &$results, $overrides=array())
	{
		$overrides = self::params($overrides);
		$pagination = array();

		if( $results instanceof ADORecordSet ) {
			$pagination['rows_per_page'] = $results->rowsPerPage;
			$pagination['total_records'] = $results->MaxRecordCount();
			$pagination['last_page'] = $results->LastPageNo();
			$pagination['current_page'] = $results->_currentPage;
		} else {
			$pagination['rows_per_page'] = $overrides['rows_per_page'];
			$pagination['total_records'] = count($results);
			if( $pagination['rows_per_page'] ) {
				$pagination['last_page'] = ceil($pagination['total_records'] / $pagination['rows_per_page']);
			} else {
				$pagination['last_page'] = 1;
			}
			$pagination['current_page'] = $overrides['current_page'];
		}

		$pagination['previous_page'] = $pagination['current_page'] - 1;
		$pagination['next_page'] = $pagination['current_page'] + 1;
		$pagination['display_start'] = (($pagination['current_page'] - 1) * $pagination['rows_per_page']) + 1;
		$pagination['display_end'] = $pagination['display_start'] + ($overrides['num_rows']?$overrides['num_rows']:($results ? $results->NumRows() : 0)) - 1;
		$pagination['params'] = (array) $params;
		$pagination['order'] = $params['order'];
		$pagination['sort'] = $params['sort'];
		unset($pagination['params']['page'], $pagination['params']['order'], $pagination['params']['sort']);
		$pagination['params'] = http_build_query($pagination['params']);

		$pagination = self::params($overrides, $pagination);
		return $pagination;
	}//end paginationInfo

	/**
	 * returns pagination results
	 */
	static function paginationResults(&$pagination, &$data)
	{
		return array('pagination' => (array) $pagination, 'items' => (array) $data);
	}//end paginationResults

	/**
	 * renders an xlsx version of the report
	 */
	public function xlsx($data, $meta = array()) {
		require_once 'phpexcel/PHPExcel.php';
		$objPHPExcel = new PHPExcel();

		// Set properties
		$default_meta = array(
			'creator' => 'PSU Tools',
			'last_modified_by' => 'PSU Tools',
			'title' => 'XLSX Export',
			'subject' => 'Plymouth State University',
			'description' => 'Generated using PSU Tools',
			'keywords' => 'office 2007 openxml php',
			'company' => 'Plymouth State University',
			'category' => 'Plymouth State University',
			'file_name' => 'export',
			'output' => 'php://output'
		);
		$meta = array_merge($default_meta, $meta);

		$objPHPExcel->setActiveSheetIndex(0);

		// generate headings
		$i = 1;

		if(count($meta['headings'])>0) {
			$col = 0;
			$letter = 'A';
			foreach($meta['headings'] as $v){
				$letter = PSU::indexToExcelAlpha($col);
				$objPHPExcel->getActiveSheet()->setCellValue($letter.$i, $v);
				$objPHPExcel->getActiveSheet()->getStyle($letter.$i)->getFont()->setBold(true);
				$objPHPExcel->getActiveSheet()->getColumnDimension($letter)->setAutoSize(true);
				$col++;
			}// end foreach
			$objPHPExcel->getActiveSheet()->getStyle('A1:'.$letter.'1')->getFill()->setFillType(PHPExcel_Style_Fill::FILL_SOLID);
			$objPHPExcel->getActiveSheet()->getStyle('A1:'.$letter.'1')->getFill()->getStartColor()->setARGB('FFdddddd');

			$i++;
		}

		// now for the actual data
		foreach($data as $row) {
			$col = 0;
			foreach($row as $key=>$value) {
				$letter = PSU::indexToExcelAlpha($col);
				
				if(is_array($meta['types'])){
					switch($meta['types'][$key]) {
						case 'boolean':
							$type = PHPExcel_Cell_DataType::TYPE_BOOL;
							break;
						case 'formula':
							$type = PHPExcel_Cell_DataType::TYPE_FORMULA;
							break;
						case 'inline':
							$type = PHPExcel_Cell_DataType::TYPE_INLINE;
							break;
						case 'null':
							$type = PHPExcel_Cell_DataType::TYPE_NULL;
							break;
						case 'number':
							$type = PHPExcel_Cell_DataType::TYPE_NUMERIC;
							break;
						case 'string':
							$type = PHPExcel_Cell_DataType::TYPE_STRING;
							break;
						default:
							$type = 'AUTOMATIC';
					}

					if($type == 'AUTOMATIC') {
						$objPHPExcel->getActiveSheet()->setCellValue($letter.$i, $value);
					}
					else {
						$objPHPExcel->getActiveSheet()->getCell($letter.$i)->setValueExplicit($value, $type);
					}
				}
				$col++;
			}//end foreach
			$i++;
		}// end foreach


		$objPHPExcel->getProperties()->setCreator($meta['creator'])
									 ->setLastModifiedBy($meta['last_modified_by'])
									 ->setTitle($meta['title'])
									 ->setSubject($meta['subject'])
									 ->setDescription($meta['description'])
									 ->setKeywords($meta['keywords'])
									 ->setCompany($meta['company'])
									 ->setCategory($meta['category']);

		if(class_exists('ZipArchive')) {
			$file_extension = 'xlsx';
			$file_type = 'Excel2007';
		}
		else {
			$file_extension = 'xls';
			$file_type = 'Excel5';
		}

		if($meta['output'] == 'php://output') {
			// Redirect output to a client
			header('Content-Type: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
			header('Content-Disposition: attachment;filename="'.$meta['file_name'].'.'.$file_extension.'"');

			self::downloadfix();
		}

		$objWriter = PHPExcel_IOFactory::createWriter($objPHPExcel, $file_type);
		$objWriter->save($meta['output']);
	}// end xlsx

	/**
	 * converts on index number to a textual excel column letters
	 */
	public static function indexToExcelAlpha($counter = 0)
	{
		// 65 is the ordinal value of 'A'
		// 26 is the number of letters in the alphabet 
		if ($counter < 26) {
			return chr(65 + $counter);
		}
		return self::indexToExcelAlpha((int)($counter / 26) -1).chr(65 + $counter%26) ;
	}// end indexToExcelAlpha

	/**
	 * redirect the browser via HTTP headers or JavaScript, whichever is more
	 * appropriate.
	 *
	 * @params			string $url the destination url
	 * @params      int $code the http response code. should be either 301 (permanent) or 302 (temporary). will be ignored if JavaScript is used for the redirect.
	 */
	function redirect($url,$code=302,$force_js=false)
	{
		if(headers_sent() || $force_js)
		{
			?>
			<SCRIPT LANGUAGE="JavaScript">
			<!--
			window.location = '<?=$url?>';
			//-->
			</SCRIPT>
			<?
		}
		else
		{
			header('Location: ' . $url, true, $code);
		}
		exit;
	}//end redirect
}//end PSU

/**
 * Exception base class.
 */
require_once('PSUException.class.php');

/**
 * Custom exception for PSUTools.
 */
class PSUToolsException extends PSUException
{
	const HTTP_FAILED = 1;
	const BAD_FILE_NAME = 2;
	const UNSAFE_INCLUDE = 3;
	const UNKNOWN_INCLUDE_TYPE = 4;
	const FILE_NOT_FOUND = 5;
	const MISSING_X_FORWARDED_FOR = 6;
	const RANDSTR_TOO_LONG_DUPES = 7;
	const BASE_DIR_MISSING = 8;

	private static $_msgs = array(
		self::HTTP_FAILED => 'HTTP transaction failed with code',
		self::BAD_FILE_NAME => 'File passed to curl helper had a bogus name',
		self::UNSAFE_INCLUDE => 'The target file is outside the allowed directory',
		self::UNKNOWN_INCLUDE_TYPE => 'An uknown include type was supplied',
		self::FILE_NOT_FOUND => 'The target file was not found',
		self::MISSING_X_FORWARDED_FOR => 'Request appeared to come from the proxy, but X-Forwarded-For was not set',
		self::RANDSTR_TOO_LONG_DUPES => 'Random string cannot be completed without duplicate characters (source list is shorter than desired random string length)',
		self::BASE_DIR_MISSING => 'Directory argument to get_svn_info was omitted, but BASE_DIR is not set'
	);

	/**
	 * PSUToolsException
	 *
	 * Wrapper construct so PSUException gets our message array.
	 *
	 * @param string $code
	 * @param mixed $append
	 */
	function __construct($code, $append=null)
	{
		parent::__construct($code, $append, self::$_msgs);
	}//end __construct
}//end PSUToolsException

/**
 * Helper class to clean up temp curl files.
 * @sa PSU
 */
class PSUToolsCurlHelper
{
	/**
	 * Internal list of files to delete.
	 */
	private $files;

	/**
	 * Add a file to the queue.
	 *
	 * @param $f name of the file. only the basename will be used.
	 */
	function add($f)
	{
		$f = basename($f);

		if(substr($f, 0, 8) != 'psutools')
		{
			throw new PSUToolsException(PSUToolsException::BAD_FILE_NAME, $f);
		}//end if

		$this->files[] = $f;
	}//end add

	/**
	 * Destructor to clean up the files in PSUTools::TEMPORARY_FILES.
	 */
	function __destruct()
	{
		foreach($this->files as $f)
		{
			if(file_exists(PSU::TEMPORARY_FILES . "/$f")) {
				unlink(PSU::TEMPORARY_FILES . "/$f");
			}
		}// end foreach
	}//end _destruct
}//end PSUToolsCurlHelper

/**
 * \section firephp FirePHP
 * %PSU automatically includes the <a href="http://www.firephp.org/">FirePHP</a> library. By default, FirePHP is enabled on uranus, and disabled everywhere else. To enable:
 *
 * <pre><code>PSU::get()->firephp->setEnabled(true);</code></pre>
 *
 * @class PSU
 */
require_once('FirePHPCore/FirePHP.class.php');
if( !isset($GLOBALS['firephp']) )
{
	$GLOBALS['firephp'] = PSU::get()->firephp = FirePHP::getInstance(true);

	// disabled by default
	if( ! PSU::isdev() )
	{
		PSU::get()->firephp->setEnabled(false);
	}//end if
}//end if
